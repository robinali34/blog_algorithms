<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://robinali34.github.io/blog_algorithms//blog_algorithms/feed.xml" rel="self" type="application/atom+xml" /><link href="https://robinali34.github.io/blog_algorithms//blog_algorithms/" rel="alternate" type="text/html" /><updated>2025-11-23T06:20:07+00:00</updated><id>https://robinali34.github.io/blog_algorithms//blog_algorithms/feed.xml</id><title type="html">Robina Li</title><subtitle>Algorithms Blog - Graduate Algorithms course notes and resources</subtitle><entry><title type="html">Reduction: 3-SAT to Exact 4-SAT</title><link href="https://robinali34.github.io/blog_algorithms//blog_algorithms/2025/11/22/reduction-3sat-to-exact-4sat/" rel="alternate" type="text/html" title="Reduction: 3-SAT to Exact 4-SAT" /><published>2025-11-22T00:00:00+00:00</published><updated>2025-11-22T00:00:00+00:00</updated><id>https://robinali34.github.io/blog_algorithms//blog_algorithms/2025/11/22/reduction-3sat-to-exact-4sat</id><content type="html" xml:base="https://robinali34.github.io/blog_algorithms//blog_algorithms/2025/11/22/reduction-3sat-to-exact-4sat/"><![CDATA[<h2 id="introduction">Introduction</h2>

<p>This post provides a detailed proof that the Exact 4-SAT problem is NP-complete by reducing from 3-SAT. The reduction transforms 3-clause formulas into 4-clause formulas while preserving satisfiability and ensuring each variable occurs at most once per clause.</p>

<h2 id="problem-definitions">Problem Definitions</h2>

<h3 id="exact-4-sat-problem">Exact 4-SAT Problem</h3>

<p><strong>Input:</strong> A set of clauses, each of which is a disjunction of exactly four literals, such that:</p>
<ul>
  <li>Each clause has exactly 4 literals</li>
  <li>Each variable occurs at most once in each clause (no variable appears twice in the same clause)</li>
  <li>Variables: x₁, x₂, …, xₙ</li>
  <li>Clauses: C₁, C₂, …, Cₘ</li>
</ul>

<p><strong>Output:</strong> YES if there exists a satisfying assignment, NO otherwise.</p>

<p><strong>Note:</strong> The goal is to find a satisfying assignment (if one exists) for the Boolean formula formed by the conjunction of all clauses.</p>

<h3 id="3-sat-problem">3-SAT Problem</h3>

<p><strong>Input:</strong> A Boolean formula φ in 3-CNF with:</p>
<ul>
  <li>Variables: x₁, x₂, …, xₙ</li>
  <li>Clauses: C₁, C₂, …, Cₘ, each with exactly 3 literals</li>
</ul>

<p><strong>Output:</strong> YES if φ is satisfiable, NO otherwise.</p>

<h2 id="1-np-completeness-proof-of-exact-4-sat-solution-validation">1. NP-Completeness Proof of Exact 4-SAT: Solution Validation</h2>

<h3 id="exact-4-sat--np">Exact 4-SAT ∈ NP</h3>

<p><strong>Verification Algorithm:</strong>
Given a candidate solution (variable assignment):</p>
<ol>
  <li>For each clause Cⱼ with exactly 4 literals:
    <ul>
      <li>Check that each variable occurs at most once: O(1) time</li>
      <li>Evaluate the clause: O(1) time</li>
      <li>Check if at least one literal is TRUE: O(1) time</li>
    </ul>
  </li>
  <li>Check that all clauses are satisfied: O(m) time</li>
</ol>

<p><strong>Total Time:</strong> O(m), which is polynomial in input size.</p>

<p><strong>Conclusion:</strong> Exact 4-SAT ∈ NP.</p>

<h2 id="2-reduce-3-sat-to-exact-4-sat">2. Reduce 3-SAT to Exact 4-SAT</h2>

<p><strong>Key Insight:</strong> Transform each 3-clause into a 4-clause by adding a new variable that doesn’t affect satisfiability. The new variable can be set to make the clause equivalent to the original 3-clause.</p>

<p><strong>Hint:</strong> For each 3-clause (l₁ ∨ l₂ ∨ l₃), create a 4-clause (l₁ ∨ l₂ ∨ l₃ ∨ y) where y is a new variable. Since y can always be set to FALSE, the satisfiability is preserved.</p>

<h3 id="21-input-conversion">2.1 Input Conversion</h3>

<p>Given a 3-SAT instance φ with n variables and m clauses, we construct an Exact 4-SAT instance φ’.</p>

<p><strong>Construction:</strong></p>

<p><strong>Step 1: Preprocess 3-SAT Instance</strong></p>
<ul>
  <li>Ensure each clause has exactly 3 distinct literals (no variable appears twice)</li>
  <li>If a clause has duplicate literals, simplify it (e.g., (x₁ ∨ x₁ ∨ x₂) → (x₁ ∨ x₂), but this would make it a 2-clause)</li>
  <li>For our reduction, we assume the 3-SAT instance has no duplicate literals within clauses</li>
</ul>

<p><strong>Step 2: Add New Variables</strong></p>
<ul>
  <li>For each clause Cⱼ, introduce a new variable yⱼ</li>
  <li>Total variables: n + m (original n variables + m new variables)</li>
</ul>

<p><strong>Step 2: Transform Clauses</strong></p>
<ul>
  <li>For each 3-clause Cⱼ = (l₁ ∨ l₂ ∨ l₃):
    <ul>
      <li>Ensure each variable appears at most once in Cⱼ (if not, the 3-SAT instance is invalid for our reduction)</li>
      <li>Create 4-clause C’ⱼ = (l₁ ∨ l₂ ∨ l₃ ∨ yⱼ)</li>
      <li>The new variable yⱼ is added as a disjunct</li>
      <li>Since yⱼ is a new variable not appearing in the original clause, each variable occurs at most once in C’ⱼ</li>
    </ul>
  </li>
</ul>

<p><strong>Step 3: Result</strong></p>
<ul>
  <li>φ’ contains m clauses, each with exactly 4 literals</li>
  <li>Each variable occurs at most once in each clause (by construction: original literals have no duplicates, and yⱼ appears only once)</li>
  <li>φ’ uses n + m variables</li>
</ul>

<p><strong>Detailed Example:</strong></p>

<p>Consider 3-SAT instance (with each variable appearing at most once per clause):</p>
<ul>
  <li>Variables: x₁, x₂, x₃</li>
  <li>Clauses: C₁ = (x₁ ∨ !x₂ ∨ x₃), C₂ = (!x₁ ∨ x₂ ∨ x₃)</li>
</ul>

<p><strong>Transformation:</strong></p>
<ul>
  <li>C’₁ = (x₁ ∨ !x₂ ∨ x₃ ∨ y₁)</li>
  <li>C’₂ = (!x₁ ∨ x₂ ∨ x₃ ∨ y₂)</li>
</ul>

<p><strong>New variables:</strong> y₁, y₂</p>

<p><strong>Verification:</strong></p>
<ul>
  <li>Each clause has exactly 4 literals: ✓</li>
  <li>Each variable occurs at most once in each clause: ✓
    <ul>
      <li>C’₁: x₁ (once), x₂ (once as !x₂), x₃ (once), y₁ (once)</li>
      <li>C’₂: x₁ (once as !x₁), x₂ (once), x₃ (once), y₂ (once)</li>
    </ul>
  </li>
</ul>

<h3 id="22-output-conversion">2.2 Output Conversion</h3>

<p><strong>Given:</strong> Exact 4-SAT solution (assignment to all n + m variables)</p>

<p><strong>Extract 3-SAT Assignment:</strong></p>
<ul>
  <li>Simply use the assignment to the original n variables</li>
  <li>Ignore the assignments to the new variables y₁, …, yₘ</li>
</ul>

<p><strong>Verify Satisfaction:</strong></p>
<ul>
  <li>For each original 3-clause Cⱼ = (l₁ ∨ l₂ ∨ l₃):
    <ul>
      <li>If Cⱼ is satisfied by the original literals, then C’ⱼ = (l₁ ∨ l₂ ∨ l₃ ∨ yⱼ) is also satisfied</li>
      <li>If Cⱼ is not satisfied, then C’ⱼ requires yⱼ = TRUE to be satisfied</li>
      <li>Since we can set yⱼ = TRUE if needed, the 4-SAT solution corresponds to a 3-SAT solution</li>
    </ul>
  </li>
</ul>

<h2 id="3-correctness-justification">3. Correctness Justification</h2>

<h3 id="31-if-3-sat-has-a-solution-then-exact-4-sat-has-a-solution">3.1 If 3-SAT has a solution, then Exact 4-SAT has a solution</h3>

<p><strong>Given:</strong> 3-SAT instance φ is satisfiable with assignment A to variables x₁, …, xₙ.</p>

<p><strong>Construct Exact 4-SAT Assignment:</strong></p>
<ul>
  <li>For original variables: Use assignment A</li>
  <li>For new variables yⱼ: Set yⱼ = FALSE for all j</li>
</ul>

<p><strong>Verify Satisfaction:</strong></p>
<ul>
  <li>For each clause C’ⱼ = (l₁ ∨ l₂ ∨ l₃ ∨ yⱼ):
    <ul>
      <li>Since original clause Cⱼ = (l₁ ∨ l₂ ∨ l₃) is satisfied by A, at least one of l₁, l₂, l₃ is TRUE</li>
      <li>Therefore, C’ⱼ is satisfied regardless of yⱼ’s value</li>
      <li>All clauses are satisfied</li>
    </ul>
  </li>
</ul>

<p><strong>Conclusion:</strong> Exact 4-SAT has a solution.</p>

<h3 id="32a-if-3-sat-does-not-have-a-solution-then-exact-4-sat-has-no-solution">3.2a If 3-SAT does not have a solution, then Exact 4-SAT has no solution</h3>

<p><strong>Given:</strong> 3-SAT instance φ is unsatisfiable.</p>

<p><strong>Proof by Contradiction:</strong></p>

<p>Assume Exact 4-SAT has a solution A’.</p>

<p><strong>Extract Assignment:</strong></p>
<ul>
  <li>For original variables: Use A’(x₁), …, A’(xₙ)</li>
  <li>This gives an assignment to the original 3-SAT instance</li>
</ul>

<p><strong>Check Clause Satisfaction:</strong></p>
<ul>
  <li>For each original clause Cⱼ = (l₁ ∨ l₂ ∨ l₃):
    <ul>
      <li>If Cⱼ is not satisfied by the original assignment, then all of l₁, l₂, l₃ are FALSE</li>
      <li>For C’ⱼ = (l₁ ∨ l₂ ∨ l₃ ∨ yⱼ) to be satisfied, we need yⱼ = TRUE</li>
      <li>However, if φ is unsatisfiable, there exists at least one clause Cⱼ that cannot be satisfied</li>
      <li>Even if we set yⱼ = TRUE for that clause, we cannot satisfy all clauses simultaneously if the original formula is unsatisfiable</li>
    </ul>
  </li>
</ul>

<p><strong>Contradiction:</strong></p>
<ul>
  <li>If φ is unsatisfiable, no assignment to x₁, …, xₙ can satisfy all clauses</li>
  <li>Adding yⱼ variables doesn’t help because each yⱼ only appears in one clause</li>
  <li>Therefore, Exact 4-SAT cannot have a solution</li>
</ul>

<p><strong>Conclusion:</strong> Exact 4-SAT has no solution.</p>

<h3 id="32b-if-exact-4-sat-has-a-solution-then-3-sat-has-a-solution">3.2b If Exact 4-SAT has a solution, then 3-SAT has a solution</h3>

<p><strong>Given:</strong> Exact 4-SAT instance φ’ has solution A’.</p>

<p><strong>Extract Variable Assignment:</strong></p>
<ul>
  <li>For original variables: Use A’(x₁), …, A’(xₙ)</li>
  <li>This gives an assignment to the original 3-SAT instance</li>
</ul>

<p><strong>Verify Clause Satisfaction:</strong></p>

<p><strong>For each original clause Cⱼ = (l₁ ∨ l₂ ∨ l₃):</strong></p>
<ul>
  <li>Corresponding 4-clause: C’ⱼ = (l₁ ∨ l₂ ∨ l₃ ∨ yⱼ)</li>
  <li>Since C’ⱼ is satisfied by A’, at least one of l₁, l₂, l₃, yⱼ is TRUE</li>
  <li>If any of l₁, l₂, l₃ is TRUE, then Cⱼ is satisfied</li>
  <li>If all of l₁, l₂, l₃ are FALSE, then yⱼ must be TRUE for C’ⱼ to be satisfied</li>
  <li>However, we can always set yⱼ = TRUE if needed, which doesn’t affect the original clause</li>
  <li>More importantly: if the original assignment satisfies the 4-clause, it must satisfy at least one of the original literals, or we can adjust yⱼ</li>
</ul>

<p><strong>Key Insight:</strong></p>
<ul>
  <li>The new variables yⱼ are “dummy” variables that don’t affect the core satisfiability</li>
  <li>If φ’ is satisfiable, then the original formula φ is also satisfiable (possibly with some yⱼ set to TRUE, but this doesn’t matter for the original problem)</li>
</ul>

<p><strong>Conclusion:</strong> The extracted assignment satisfies all original clauses, so 3-SAT has a solution.</p>

<h2 id="polynomial-time-analysis">Polynomial Time Analysis</h2>

<p><strong>Input Size:</strong></p>
<ul>
  <li>3-SAT: n variables, m clauses</li>
  <li>Exact 4-SAT: n + m variables, m clauses</li>
</ul>

<p><strong>Construction Time:</strong></p>
<ul>
  <li>For each clause: Add one literal (new variable): O(1) time</li>
  <li>Total: O(m) time</li>
</ul>

<p><strong>Conclusion:</strong> Reduction is polynomial-time.</p>

<h2 id="summary">Summary</h2>

<p>We have shown:</p>
<ol>
  <li><strong>Exact 4-SAT ∈ NP</strong>: Solutions can be verified in polynomial time</li>
  <li><strong>3-SAT ≤ₚ Exact 4-SAT</strong>: Polynomial-time reduction exists</li>
  <li><strong>Correctness</strong>: 3-SAT satisfiable ↔ Exact 4-SAT satisfiable</li>
</ol>

<p><strong>Therefore, Exact 4-SAT is NP-complete.</strong></p>

<h2 id="key-insights">Key Insights</h2>

<ol>
  <li><strong>Variable Addition</strong>: Adding a new variable to each clause doesn’t change satisfiability when the variable can be set appropriately</li>
  <li><strong>Clause Expansion</strong>: Expanding 3-clauses to 4-clauses preserves satisfiability</li>
  <li><strong>Uniqueness Constraint</strong>: The constraint that each variable occurs at most once per clause is preserved because the original 3-SAT clauses have no duplicates, and the new variable yⱼ appears only once</li>
  <li><strong>Dummy Variables</strong>: The new variables serve as “safety valves” that can always be set to satisfy clauses if needed</li>
  <li><strong>Preservation</strong>: The reduction preserves the core structure of the satisfiability problem</li>
</ol>

<h2 id="practice-questions">Practice Questions</h2>

<ol>
  <li><strong>Extend the reduction</strong> to reduce k-SAT to Exact (k+1)-SAT. Does the same approach work?</li>
  <li><strong>Modify the reduction</strong> to reduce 3-SAT to Exact 3-SAT (where each clause has exactly 3 literals, but variables may appear different numbers of times). What changes?</li>
  <li><strong>Analyze the reverse reduction:</strong> Can we reduce Exact 4-SAT to 3-SAT? How?</li>
  <li><strong>Consider the number of new variables:</strong> Could we use fewer new variables? What’s the minimum?</li>
  <li><strong>Prove the reduction</strong> works for the decision version: does it also work for optimization versions?</li>
</ol>

<hr />

<p>This reduction demonstrates how adding “dummy” variables can transform clause structures while preserving satisfiability, enabling reductions between similar SAT variants.</p>]]></content><author><name></name></author><category term="Algorithms" /><category term="Complexity Theory" /><category term="NP-Hard" /><summary type="html"><![CDATA[A detailed proof showing how to reduce 3-SAT to Exact 4-SAT, demonstrating that Exact 4-SAT is NP-complete.]]></summary></entry><entry><title type="html">Reduction: Clique to Clique-3</title><link href="https://robinali34.github.io/blog_algorithms//blog_algorithms/2025/11/22/reduction-clique-to-clique-3/" rel="alternate" type="text/html" title="Reduction: Clique to Clique-3" /><published>2025-11-22T00:00:00+00:00</published><updated>2025-11-22T00:00:00+00:00</updated><id>https://robinali34.github.io/blog_algorithms//blog_algorithms/2025/11/22/reduction-clique-to-clique-3</id><content type="html" xml:base="https://robinali34.github.io/blog_algorithms//blog_algorithms/2025/11/22/reduction-clique-to-clique-3/"><![CDATA[<h2 id="introduction">Introduction</h2>

<p>This post provides a detailed proof that the Clique-3 problem is NP-complete by reducing from Clique. Clique-3 is the Clique problem restricted to graphs where every vertex has degree at most 3, showing that even this restricted version remains computationally hard.</p>

<h2 id="problem-definitions">Problem Definitions</h2>

<h3 id="clique-3-problem">Clique-3 Problem</h3>

<p><strong>Input:</strong></p>
<ul>
  <li>An undirected graph G = (V, E) where every vertex has degree at most 3</li>
  <li>Integer k ≥ 1</li>
</ul>

<p><strong>Output:</strong> YES if G contains a clique of size k (set of k vertices, all pairwise adjacent), NO otherwise.</p>

<p><strong>Note:</strong> This is the CLIQUE problem restricted to graphs in which every vertex has degree at most 3.</p>

<h3 id="clique-problem">Clique Problem</h3>

<p><strong>Input:</strong></p>
<ul>
  <li>An undirected graph G = (V, E)</li>
  <li>Integer k ≥ 1</li>
</ul>

<p><strong>Output:</strong> YES if G contains a clique of size k (set of k vertices, all pairwise adjacent), NO otherwise.</p>

<h2 id="1-np-completeness-proof-of-clique-3-solution-validation">1. NP-Completeness Proof of Clique-3: Solution Validation</h2>

<h3 id="clique-3--np">Clique-3 ∈ NP</h3>

<p><strong>Verification Algorithm:</strong>
Given a candidate solution (set C of k vertices):</p>
<ol>
  <li>Check that C has exactly k vertices: O(1) time</li>
  <li>Check that all pairs in C are adjacent: O(k²) time</li>
</ol>

<p><strong>Total Time:</strong> O(k²), which is polynomial in input size.</p>

<p><strong>Conclusion:</strong> Clique-3 ∈ NP.</p>

<h2 id="2-reduce-clique-to-clique-3">2. Reduce Clique to Clique-3</h2>

<p><strong>Key Insight:</strong> Given a Clique instance, we can reduce it to Clique-3 by replacing high-degree vertices with gadgets that preserve clique structure while ensuring all vertices have degree at most 3. We use a local replacement strategy where each vertex v with degree d &gt; 3 is replaced with a structure that maintains clique relationships.</p>

<table>
  <tbody>
    <tr>
      <td><strong>Hint:</strong> For a vertex v with neighbors N(v) where</td>
      <td>N(v)</td>
      <td>&gt; 3, replace v with a chain of vertices connected in a way that distributes the neighbors among the chain vertices, ensuring each vertex in the chain has degree ≤ 3. The clique property is preserved: if v was in a clique, all vertices in its replacement chain are in the corresponding clique.</td>
    </tr>
  </tbody>
</table>

<h3 id="21-input-conversion">2.1 Input Conversion</h3>

<p>Given a Clique instance (G, k) where G = (V, E) with n vertices, we construct a Clique-3 instance (G’, k’).</p>

<p><strong>Construction:</strong></p>

<p><strong>Step 1: Identify High-Degree Vertices</strong></p>
<ul>
  <li>For each vertex v ∈ V:
    <ul>
      <li>If deg(v) ≤ 3: keep v as is</li>
      <li>If deg(v) &gt; 3: mark v for replacement</li>
    </ul>
  </li>
</ul>

<p><strong>Step 2: Replace High-Degree Vertices</strong></p>
<ul>
  <li>For each vertex v with deg(v) = d &gt; 3:
    <ul>
      <li>Let N(v) = {u₁, u₂, …, u_d} be the neighbors of v</li>
      <li>Replace v with a chain of vertices: v₁, v₂, …, v_{d-2}</li>
      <li>Connect the chain: (v₁, v₂), (v₂, v₃), …, (v_{d-3}, v_{d-2})</li>
      <li>Distribute neighbors:
        <ul>
          <li>Connect u₁, u₂ to v₁</li>
          <li>Connect u₃ to v₂</li>
          <li>Connect u₄ to v₃</li>
          <li>…</li>
          <li>Connect u_d to v_{d-2}</li>
        </ul>
      </li>
      <li>Make all vᵢ pairwise adjacent (form a clique among themselves)</li>
      <li>This ensures:
        <ul>
          <li>Each vᵢ has degree ≤ 3 (at most 2 neighbors in chain + 1-2 external neighbors)</li>
          <li>If v was in a clique, all vᵢ must be in the corresponding clique</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><strong>Step 3: Adjust Clique Size</strong></p>
<ul>
  <li>For each replaced vertex v with degree d &gt; 3:
    <ul>
      <li>Original clique size increases by (d-3) vertices</li>
    </ul>
  </li>
  <li>Let r be the number of replaced vertices</li>
  <li>Let D be the sum of (deg(v) - 3) over all replaced vertices v</li>
  <li>Set k’ = k + D</li>
</ul>

<p><strong>Step 4: Result</strong></p>
<ul>
  <li>Clique-3 instance: (G’, k’)</li>
</ul>

<p><strong>Detailed Example:</strong></p>

<p>Consider Clique instance:</p>
<ul>
  <li>Graph G with vertices {1, 2, 3, 4, 5}</li>
  <li>Edges: {(1,2), (1,3), (1,4), (1,5), (2,3), (3,4)}</li>
  <li>Vertex 1 has degree 4 &gt; 3</li>
  <li>k = 3</li>
</ul>

<p><strong>Transformation:</strong></p>
<ul>
  <li>Replace vertex 1 (degree 4) with chain: 1a, 1b</li>
  <li>Connect chain: (1a, 1b)</li>
  <li>Distribute neighbors:
    <ul>
      <li>Connect 2, 3 to 1a (deg(1a) = 3: neighbors 1b, 2, 3)</li>
      <li>Connect 4, 5 to 1b (deg(1b) = 3: neighbors 1a, 4, 5)</li>
    </ul>
  </li>
  <li>Make 1a and 1b adjacent (they form a clique)</li>
  <li>New graph G’ has all vertices with degree ≤ 3</li>
  <li>k’ = 3 + (4-3) = 4 (need clique of size 4 in G’)</li>
</ul>

<h3 id="22-output-conversion">2.2 Output Conversion</h3>

<p><strong>Given:</strong> Clique-3 solution (clique C’ of size k’ in G’)</p>

<p><strong>Extract Clique:</strong></p>
<ul>
  <li>For each original vertex v:
    <ul>
      <li>If v was not replaced: include v in C if v ∈ C’</li>
      <li>If v was replaced by chain v₁, …, v_{d-2}:
        <ul>
          <li>Include v in C if all vᵢ are in C’</li>
          <li>(Since all vᵢ form a clique, if any are in C’, all must be in C’)</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><strong>Verify Satisfaction:</strong></p>
<ul>
  <li>C has size k (by construction, accounting for replacements)</li>
  <li>All pairs in C are adjacent:
    <ul>
      <li>If both vertices were not replaced: edge exists in G (preserved in G’)</li>
      <li>If one was replaced: the replacement chain connects to neighbors</li>
      <li>If both were replaced: their replacement chains are fully connected</li>
    </ul>
  </li>
</ul>

<h2 id="3-correctness-justification">3. Correctness Justification</h2>

<h3 id="31-if-clique-has-a-solution-then-clique-3-has-a-solution">3.1 If Clique has a solution, then Clique-3 has a solution</h3>

<p><strong>Given:</strong> Clique instance (G, k) has solution C (clique of size k).</p>

<p><strong>Construct Clique-3 Solution:</strong></p>
<ul>
  <li>For each vertex v ∈ C:
    <ul>
      <li>If v was not replaced: include v in C’</li>
      <li>If v was replaced by chain v₁, …, v_{d-2}: include all vᵢ in C’</li>
    </ul>
  </li>
  <li>For each replaced vertex v ∉ C:
    <ul>
      <li>Do not include any vᵢ in C’</li>
    </ul>
  </li>
</ul>

<p><strong>Verify Satisfaction:</strong></p>
<ul>
  <li>C’ has size k’: ✓ (by construction, k’ accounts for replacements)</li>
  <li>All pairs in C’ are adjacent:
    <ul>
      <li>Vertices from same replacement chain: ✓ (all vᵢ form a clique)</li>
      <li>Vertices from different replacement chains: ✓ (if original vertices were adjacent, their chains are connected)</li>
      <li>Original vertices: ✓ (edges preserved)</li>
    </ul>
  </li>
  <li>All vertices in G’ have degree ≤ 3: ✓ (by construction)</li>
</ul>

<p><strong>Conclusion:</strong> Clique-3 has a solution.</p>

<h3 id="32a-if-clique-does-not-have-a-solution-then-clique-3-has-no-solution">3.2a If Clique does not have a solution, then Clique-3 has no solution</h3>

<p><strong>Given:</strong> Clique instance (G, k) has no solution (no clique of size k).</p>

<p><strong>Proof:</strong></p>

<p><strong>Assume:</strong> Clique-3 instance (G’, k’) has a solution (clique C’ of size k’).</p>

<p><strong>Extract Clique:</strong></p>
<ul>
  <li>For each original vertex v:
    <ul>
      <li>If v was not replaced and v ∈ C’: include v in C</li>
      <li>If v was replaced and all vᵢ ∈ C’: include v in C</li>
    </ul>
  </li>
  <li>C has size k (by reversing the replacement accounting)</li>
</ul>

<p><strong>Check Adjacency:</strong></p>
<ul>
  <li>For any two vertices u, v ∈ C:
    <ul>
      <li>If both were not replaced: edge (u,v) exists in G (preserved in G’)</li>
      <li>If one was replaced: the replacement connects to neighbors</li>
      <li>If both were replaced: their replacement chains are connected</li>
    </ul>
  </li>
  <li>Therefore, C is a clique in G</li>
</ul>

<p><strong>Contradiction:</strong></p>
<ul>
  <li>C is a clique of size k in G</li>
  <li>This contradicts the assumption that G has no clique of size k</li>
</ul>

<p><strong>Conclusion:</strong> Clique-3 has no solution.</p>

<h3 id="32b-if-clique-3-has-a-solution-then-clique-has-a-solution">3.2b If Clique-3 has a solution, then Clique has a solution</h3>

<p><strong>Given:</strong> Clique-3 instance (G’, k’) has solution (clique C’ of size k’).</p>

<p><strong>Extract Clique:</strong></p>
<ul>
  <li>For each original vertex v:
    <ul>
      <li>If v was not replaced: include v in C if v ∈ C’</li>
      <li>If v was replaced by chain v₁, …, v_{d-2}:
        <ul>
          <li>Include v in C if all vᵢ are in C’</li>
          <li>(Since replacement chains form cliques, if any vᵢ is in C’, all must be in C’ for C’ to be a clique)</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><strong>Verify Satisfaction:</strong></p>

<p><strong>Clique Requirements:</strong></p>
<ul>
  <li>C has size k: ✓ (by construction, accounting for replacements)</li>
  <li>All pairs in C are adjacent:
    <ul>
      <li>If both vertices were not replaced: edge exists in G (preserved in G’)</li>
      <li>If one was replaced: the replacement chain connects to the neighbor</li>
      <li>If both were replaced: their replacement chains are fully connected (by construction)</li>
    </ul>
  </li>
</ul>

<p><strong>Key Insight:</strong></p>
<ul>
  <li>The replacement preserves clique structure: if original vertices form a clique, their replacements form a clique</li>
  <li>The degree constraint is satisfied: all vertices in G’ have degree ≤ 3</li>
  <li>The clique size is adjusted to account for vertex replacements</li>
</ul>

<p><strong>Conclusion:</strong> The set C forms a clique of size k in G, so Clique has a solution.</p>

<h2 id="polynomial-time-analysis">Polynomial Time Analysis</h2>

<p><strong>Input Size:</strong></p>
<ul>
  <li>Clique: Graph G with n vertices and m edges, integer k</li>
  <li>Clique-3: Graph G’ with at most n + O(m) vertices (each high-degree vertex replaced by O(deg(v)) vertices), integer k’</li>
</ul>

<p><strong>Construction Time:</strong></p>
<ul>
  <li>Identify high-degree vertices: O(n) time</li>
  <li>For each high-degree vertex v with degree d:
    <ul>
      <li>Create replacement chain: O(d) time</li>
      <li>Connect neighbors: O(d) time</li>
    </ul>
  </li>
  <li>Total: O(n + m) time</li>
</ul>

<p><strong>Conclusion:</strong> Reduction is polynomial-time.</p>

<h2 id="summary">Summary</h2>

<p>We have shown:</p>
<ol>
  <li><strong>Clique-3 ∈ NP</strong>: Solutions can be verified in polynomial time</li>
  <li><strong>Clique ≤ₚ Clique-3</strong>: Polynomial-time reduction exists</li>
  <li><strong>Correctness</strong>: Clique has solution ↔ Clique-3 has solution</li>
</ol>

<p><strong>Therefore, Clique-3 is NP-complete.</strong></p>

<h2 id="key-insights">Key Insights</h2>

<ol>
  <li><strong>Degree Reduction Gadget</strong>: Replacing high-degree vertices with chains preserves clique structure</li>
  <li><strong>Local Replacement</strong>: Each vertex replacement is local and doesn’t affect distant parts of the graph</li>
  <li><strong>Clique Preservation</strong>: The replacement ensures that cliques in the original graph correspond to cliques in the transformed graph</li>
  <li><strong>Size Adjustment</strong>: The clique size parameter is adjusted to account for vertex replacements</li>
</ol>

<h2 id="practice-questions">Practice Questions</h2>

<ol>
  <li><strong>Modify the reduction</strong> to handle directed graphs. How would the gadget change?</li>
  <li><strong>Analyze the gadget size:</strong> Can we use a more efficient replacement that creates fewer vertices?</li>
  <li><strong>Consider other degree bounds:</strong> How would you reduce Clique to Clique-d for d = 2? Is it still NP-complete?</li>
  <li><strong>Prove the reverse reduction:</strong> Can we reduce Clique-3 to Clique? How?</li>
  <li><strong>Investigate special cases:</strong> For what graph classes is Clique-3 polynomial-time solvable?</li>
</ol>

<hr />

<p>This reduction demonstrates that even highly restricted versions of Clique (with bounded degree) remain NP-complete, showing the robustness of the problem’s computational hardness.</p>]]></content><author><name></name></author><category term="Algorithms" /><category term="Complexity Theory" /><category term="NP-Hard" /><summary type="html"><![CDATA[A detailed proof showing how to reduce Clique to Clique-3, demonstrating that Clique-3 is NP-complete.]]></summary></entry><entry><title type="html">Reduction: Clique to Dense Subgraph</title><link href="https://robinali34.github.io/blog_algorithms//blog_algorithms/2025/11/22/reduction-clique-to-dense-subgraph/" rel="alternate" type="text/html" title="Reduction: Clique to Dense Subgraph" /><published>2025-11-22T00:00:00+00:00</published><updated>2025-11-22T00:00:00+00:00</updated><id>https://robinali34.github.io/blog_algorithms//blog_algorithms/2025/11/22/reduction-clique-to-dense-subgraph</id><content type="html" xml:base="https://robinali34.github.io/blog_algorithms//blog_algorithms/2025/11/22/reduction-clique-to-dense-subgraph/"><![CDATA[<h2 id="introduction">Introduction</h2>

<p>This post provides a detailed proof that the Dense Subgraph problem is NP-complete by reducing from Clique. Dense Subgraph asks for a set of vertices with a specified number of edges between them, generalizing the clique problem.</p>

<h2 id="problem-definitions">Problem Definitions</h2>

<h3 id="dense-subgraph-problem">Dense Subgraph Problem</h3>

<p><strong>Input:</strong></p>
<ul>
  <li>An undirected graph G = (V, E)</li>
  <li>Two integers a ≥ 1 and b ≥ 0</li>
</ul>

<p><strong>Output:</strong> YES if there exists a set of a vertices of G such that there are at least b edges between them, NO otherwise.</p>

<p><strong>Note:</strong> The problem asks to find a set S ⊆ V with <code class="language-plaintext highlighter-rouge">|S|</code> = a such that the number of edges in the subgraph induced by S is at least b.</p>

<h3 id="clique-problem">Clique Problem</h3>

<p><strong>Input:</strong></p>
<ul>
  <li>An undirected graph G = (V, E)</li>
  <li>Integer k ≥ 1</li>
</ul>

<p><strong>Output:</strong> YES if G contains a clique of size k (set of k vertices, all pairwise adjacent), NO otherwise.</p>

<h2 id="1-np-completeness-proof-of-dense-subgraph-solution-validation">1. NP-Completeness Proof of Dense Subgraph: Solution Validation</h2>

<h3 id="dense-subgraph--np">Dense Subgraph ∈ NP</h3>

<p><strong>Verification Algorithm:</strong>
Given a candidate solution (set S of a vertices):</p>
<ol>
  <li>Check that <code class="language-plaintext highlighter-rouge">|S|</code> = a: O(1) time</li>
  <li>Count the number of edges in the subgraph induced by S: O(a²) time</li>
  <li>Check if the count ≥ b: O(1) time</li>
</ol>

<p><strong>Total Time:</strong> O(a²), which is polynomial in input size.</p>

<p><strong>Conclusion:</strong> Dense Subgraph ∈ NP.</p>

<h2 id="2-reduce-clique-to-dense-subgraph">2. Reduce Clique to Dense Subgraph</h2>

<p><strong>Key Insight:</strong> Given a Clique instance, we can reduce it to Dense Subgraph by setting a = k and b = k(k-1)/2. A clique of size k has exactly k(k-1)/2 edges (all pairs are adjacent). Therefore, finding a k-clique is equivalent to finding a set of k vertices with at least k(k-1)/2 edges.</p>

<p><strong>Hint:</strong> A complete graph on k vertices has k(k-1)/2 edges. Therefore, a set of k vertices forms a clique if and only if it has exactly k(k-1)/2 edges. Setting b = k(k-1)/2 ensures we find a clique.</p>

<h3 id="21-input-conversion">2.1 Input Conversion</h3>

<p>Given a Clique instance (G, k) where G = (V, E) with n vertices, we construct a Dense Subgraph instance (G’, a, b).</p>

<p><strong>Construction:</strong></p>

<p><strong>Step 1: Copy Graph</strong></p>
<ul>
  <li>G’ = G (same graph, no changes)</li>
</ul>

<p><strong>Step 2: Set Parameters</strong></p>
<ul>
  <li>a = k (we want a set of k vertices)</li>
  <li>b = k(k-1)/2 (a clique of size k has exactly this many edges)</li>
</ul>

<p><strong>Step 3: Result</strong></p>
<ul>
  <li>Dense Subgraph instance: (G’, k, k(k-1)/2)</li>
</ul>

<p><strong>Detailed Example:</strong></p>

<p>Consider Clique instance:</p>
<ul>
  <li>Graph G with vertices {1, 2, 3, 4}</li>
  <li>Edges: {(1,2), (1,3), (2,3), (2,4), (3,4)}</li>
  <li>k = 3 (want clique of size 3)</li>
</ul>

<p><strong>Transformation:</strong></p>
<ul>
  <li>G’ = G (same graph)</li>
  <li>a = 3</li>
  <li>b = 3(3-1)/2 = 3</li>
</ul>

<p><strong>Dense Subgraph instance:</strong> (G’, 3, 3)</p>

<p><strong>Note:</strong> A set of 3 vertices with at least 3 edges must have exactly 3 edges, which means all pairs are adjacent (a 3-clique).</p>

<h3 id="22-output-conversion">2.2 Output Conversion</h3>

<p><strong>Given:</strong> Dense Subgraph solution (set S of a = k vertices with at least b = k(k-1)/2 edges)</p>

<p><strong>Extract Clique:</strong></p>
<ul>
  <li>Use S as the clique</li>
  <li>S has k vertices</li>
  <li>S has at least k(k-1)/2 edges</li>
  <li>Since a set of k vertices can have at most k(k-1)/2 edges (complete graph), S has exactly k(k-1)/2 edges</li>
  <li>Therefore, all pairs of vertices in S are adjacent</li>
  <li>S is a clique of size k</li>
</ul>

<p><strong>Verify Satisfaction:</strong></p>
<ul>
  <li>S has k vertices: ✓</li>
  <li>All pairs of vertices in S are adjacent: ✓ (since there are k(k-1)/2 edges)</li>
  <li>Therefore, S is a clique of size k</li>
</ul>

<h2 id="3-correctness-justification">3. Correctness Justification</h2>

<h3 id="31-if-clique-has-a-solution-then-dense-subgraph-has-a-solution">3.1 If Clique has a solution, then Dense Subgraph has a solution</h3>

<p><strong>Given:</strong> Clique instance (G, k) has solution C (clique of size k).</p>

<p><strong>Construct Dense Subgraph Solution:</strong></p>
<ul>
  <li>Use C as the set S</li>
  <li>S = C has k = a vertices</li>
  <li>Since C is a clique, all pairs of vertices in C are adjacent</li>
  <li>Therefore, C has exactly k(k-1)/2 edges</li>
  <li>Number of edges = k(k-1)/2 ≥ b = k(k-1)/2 ✓</li>
</ul>

<p><strong>Verify Satisfaction:</strong></p>
<ul>
  <li>S has a = k vertices: ✓ (since C has k vertices)</li>
  <li>S has at least b = k(k-1)/2 edges: ✓ (since C is a clique)</li>
  <li>Therefore, S is a solution to Dense Subgraph</li>
</ul>

<p><strong>Conclusion:</strong> Dense Subgraph has a solution.</p>

<h3 id="32a-if-clique-does-not-have-a-solution-then-dense-subgraph-has-no-solution">3.2a If Clique does not have a solution, then Dense Subgraph has no solution</h3>

<p><strong>Given:</strong> Clique instance (G, k) has no solution (no clique of size k).</p>

<p><strong>Proof:</strong></p>

<p><strong>Assume:</strong> Dense Subgraph instance (G’, k, k(k-1)/2) has a solution (set S of k vertices with at least k(k-1)/2 edges).</p>

<p><strong>Extract Clique:</strong></p>
<ul>
  <li>Use S as the candidate clique</li>
  <li>S has k vertices</li>
  <li>S has at least k(k-1)/2 edges</li>
  <li>Since a set of k vertices can have at most k(k-1)/2 edges, S has exactly k(k-1)/2 edges</li>
  <li>Therefore, all pairs of vertices in S are adjacent</li>
  <li>S is a clique of size k in G’ = G</li>
</ul>

<p><strong>Contradiction:</strong></p>
<ul>
  <li>S is a clique of size k in G</li>
  <li>This contradicts the assumption that G has no clique of size k</li>
</ul>

<p><strong>Conclusion:</strong> Dense Subgraph has no solution.</p>

<h3 id="32b-if-dense-subgraph-has-a-solution-then-clique-has-a-solution">3.2b If Dense Subgraph has a solution, then Clique has a solution</h3>

<p><strong>Given:</strong> Dense Subgraph instance (G’, k, k(k-1)/2) has solution (set S of k vertices with at least k(k-1)/2 edges).</p>

<p><strong>Extract Clique:</strong></p>
<ul>
  <li>Use S as the clique</li>
  <li>S has k vertices</li>
  <li>S has at least k(k-1)/2 edges</li>
  <li>Since a set of k vertices can have at most k(k-1)/2 edges (complete graph), S has exactly k(k-1)/2 edges</li>
  <li>Therefore, all pairs of vertices in S are adjacent</li>
</ul>

<p><strong>Verify Satisfaction:</strong></p>

<p><strong>Clique Requirements:</strong></p>
<ul>
  <li>S has exactly k vertices: ✓ (by assumption)</li>
  <li>All pairs of vertices in S are adjacent: ✓ (since there are k(k-1)/2 edges, which is the maximum)</li>
  <li>Therefore, S is a clique of size k in G’ = G</li>
</ul>

<p><strong>Key Insight:</strong></p>
<ul>
  <li>A set of k vertices can have at most k(k-1)/2 edges (when it forms a complete graph)</li>
  <li>Requiring at least k(k-1)/2 edges forces the set to have exactly k(k-1)/2 edges</li>
  <li>This means all pairs must be adjacent, which is exactly the definition of a clique</li>
  <li>Therefore, any solution to Dense Subgraph gives us a clique</li>
</ul>

<p><strong>Conclusion:</strong> The set S forms a clique of size k in G, so Clique has a solution.</p>

<h2 id="polynomial-time-analysis">Polynomial Time Analysis</h2>

<p><strong>Input Size:</strong></p>
<ul>
  <li>Clique: Graph G with n vertices and m edges, integer k</li>
  <li>Dense Subgraph: Graph G’ with n vertices and m edges, integers a = k and b = k(k-1)/2</li>
</ul>

<p><strong>Construction Time:</strong></p>
<ul>
  <li>Copy graph G: O(n + m) time</li>
  <li>Set a = k: O(1) time</li>
  <li>Set b = k(k-1)/2: O(1) time</li>
  <li>Total: O(n + m) time</li>
</ul>

<p><strong>Conclusion:</strong> Reduction is polynomial-time.</p>

<h2 id="summary">Summary</h2>

<p>We have shown:</p>
<ol>
  <li><strong>Dense Subgraph ∈ NP</strong>: Solutions can be verified in polynomial time</li>
  <li><strong>Clique ≤ₚ Dense Subgraph</strong>: Polynomial-time reduction exists</li>
  <li><strong>Correctness</strong>: Clique has solution ↔ Dense Subgraph has solution</li>
</ol>

<p><strong>Therefore, Dense Subgraph is NP-complete.</strong></p>

<h2 id="key-insights">Key Insights</h2>

<ol>
  <li><strong>Edge Count Equivalence</strong>: A clique of size k has exactly k(k-1)/2 edges (the maximum possible)</li>
  <li><strong>Maximum Constraint</strong>: Requiring at least k(k-1)/2 edges forces exactly k(k-1)/2 edges (since that’s the maximum)</li>
  <li><strong>Clique Characterization</strong>: A set of k vertices is a clique if and only if it has k(k-1)/2 edges</li>
  <li><strong>Preservation</strong>: The reduction preserves the clique structure through edge count requirements</li>
</ol>

<h2 id="practice-questions">Practice Questions</h2>

<ol>
  <li><strong>Modify the reduction</strong> to reduce k-Clique to Dense Subgraph for fixed k. Does the complexity change?</li>
  <li><strong>Extend the reduction</strong> to handle weighted graphs. How would you set the parameters?</li>
  <li><strong>Consider the optimization version:</strong> How would you reduce the optimization version of Clique to Dense Subgraph?</li>
  <li><strong>Prove the reverse reduction:</strong> Can we reduce Dense Subgraph to Clique? How?</li>
  <li><strong>Investigate special cases:</strong> For what values of a and b is Dense Subgraph polynomial-time solvable?</li>
</ol>

<hr />

<p>This reduction demonstrates how edge density constraints can encode clique requirements, enabling reductions between graph structure problems.</p>]]></content><author><name></name></author><category term="Algorithms" /><category term="Complexity Theory" /><category term="NP-Hard" /><summary type="html"><![CDATA[A detailed proof showing how to reduce Clique to Dense Subgraph, demonstrating that Dense Subgraph is NP-complete.]]></summary></entry><entry><title type="html">Reduction: Clique to Kite</title><link href="https://robinali34.github.io/blog_algorithms//blog_algorithms/2025/11/22/reduction-clique-to-kite/" rel="alternate" type="text/html" title="Reduction: Clique to Kite" /><published>2025-11-22T00:00:00+00:00</published><updated>2025-11-22T00:00:00+00:00</updated><id>https://robinali34.github.io/blog_algorithms//blog_algorithms/2025/11/22/reduction-clique-to-kite</id><content type="html" xml:base="https://robinali34.github.io/blog_algorithms//blog_algorithms/2025/11/22/reduction-clique-to-kite/"><![CDATA[<h2 id="introduction">Introduction</h2>

<p>This post provides a detailed proof that the Kite problem is NP-complete by reducing from Clique. A kite is a graph structure consisting of a clique with a path (tail) attached, and the problem asks whether a graph contains such a structure of a given size.</p>

<h2 id="problem-definitions">Problem Definitions</h2>

<h3 id="kite-problem">Kite Problem</h3>

<p><strong>Input:</strong></p>
<ul>
  <li>An undirected graph G = (V, E)</li>
  <li>A goal g ≥ 1</li>
</ul>

<p><strong>Output:</strong> YES if G contains a subgraph which is a kite and which contains 2g nodes, NO otherwise.</p>

<p><strong>Kite Definition:</strong> A kite is a graph on an even number of vertices, say 2n, in which:</p>
<ul>
  <li>n vertices form a clique</li>
  <li>The remaining n vertices are connected in a “tail” that consists of a path</li>
  <li>The tail is joined to one of the vertices of the clique</li>
</ul>

<p><strong>Note:</strong> The kite has exactly 2n = 2g vertices total, with n = g vertices in the clique and n = g vertices in the tail.</p>

<h3 id="clique-problem">Clique Problem</h3>

<p><strong>Input:</strong></p>
<ul>
  <li>An undirected graph G = (V, E)</li>
  <li>Integer k ≥ 1</li>
</ul>

<p><strong>Output:</strong> YES if G contains a clique of size k (set of k vertices, all pairwise adjacent), NO otherwise.</p>

<h2 id="1-np-completeness-proof-of-kite-solution-validation">1. NP-Completeness Proof of Kite: Solution Validation</h2>

<h3 id="kite--np">Kite ∈ NP</h3>

<p><strong>Verification Algorithm:</strong>
Given a candidate solution (subgraph K with 2g vertices):</p>
<ol>
  <li>Check that K has exactly 2g vertices: O(1) time</li>
  <li>Identify the clique part (g vertices): O(g²) time</li>
  <li>Check that the clique part forms a clique: O(g²) time</li>
  <li>Identify the tail part (g vertices): O(g) time</li>
  <li>Check that the tail forms a path: O(g) time</li>
  <li>Check that the tail is connected to exactly one vertex of the clique: O(1) time</li>
</ol>

<p><strong>Total Time:</strong> O(g²), which is polynomial in input size.</p>

<p><strong>Conclusion:</strong> Kite ∈ NP.</p>

<h2 id="2-reduce-clique-to-kite">2. Reduce Clique to Kite</h2>

<p><strong>Key Insight:</strong> Given a Clique instance, we can reduce it to Kite by adding a tail of k vertices to the graph, with the tail’s first vertex connected to all original vertices. Then G has a k-clique if and only if the modified graph has a kite with 2k vertices.</p>

<p><strong>Hint:</strong> For a kite with 2g = 2k vertices, we need k vertices forming a clique and k vertices forming a tail. If G has a k-clique C, we can use C as the clique part and attach the tail to any vertex in C. We construct G’ by adding a tail of k vertices, with the first tail vertex connected to all original vertices, allowing the tail to attach to any vertex.</p>

<h3 id="21-input-conversion">2.1 Input Conversion</h3>

<p>Given a Clique instance (G, k) where G = (V, E) with n vertices, we construct a Kite instance (G’, g).</p>

<p><strong>Construction:</strong></p>

<p><strong>Step 1: Add Tail</strong></p>
<ul>
  <li>Add k new vertices: t₁, t₂, …, tₖ</li>
  <li>Connect them to form a path: (t₁, t₂), (t₂, t₃), …, (tₖ₋₁, tₖ)</li>
  <li>Connect t₁ to all vertices in V (the tail’s first vertex connects to all original vertices)</li>
  <li>This allows the tail to attach to any vertex in the original graph</li>
</ul>

<p><strong>Step 2: Set Goal</strong></p>
<ul>
  <li>g = k (we want a kite with 2k = 2g vertices)</li>
</ul>

<p><strong>Step 3: Result</strong></p>
<ul>
  <li>Kite instance: (G’, k) where G’ has the original graph plus the tail</li>
</ul>

<p><strong>Detailed Example:</strong></p>

<p>Consider Clique instance:</p>
<ul>
  <li>Graph G with vertices {1, 2, 3, 4}</li>
  <li>Edges: {(1,2), (1,3), (2,3), (2,4), (3,4)}</li>
  <li>k = 3 (want clique of size 3)</li>
</ul>

<p><strong>Transformation:</strong></p>
<ul>
  <li>Add tail vertices: t₁, t₂, t₃</li>
  <li>Add tail edges: (t₁, t₂), (t₂, t₃)</li>
  <li>Connect t₁ to all original vertices: (t₁,1), (t₁,2), (t₁,3), (t₁,4)</li>
  <li>g = 3</li>
</ul>

<p><strong>Kite instance:</strong> (G’, 3)</p>

<h3 id="22-output-conversion">2.2 Output Conversion</h3>

<p><strong>Given:</strong> Kite solution (subgraph K that is a kite with 2g = 2k vertices)</p>

<p><strong>Extract Clique:</strong></p>
<ul>
  <li>The kite K has 2k vertices: k in the clique part and k in the tail part</li>
  <li>The tail vertices t₁, …, tₖ form a path, so they cannot be part of the clique part</li>
  <li>Therefore, the clique part must consist entirely of k vertices from the original graph G</li>
  <li>These k vertices form a clique in G (since edges are preserved from G to G’)</li>
</ul>

<p><strong>Verify Satisfaction:</strong></p>
<ul>
  <li>We extract k vertices from G that form a clique</li>
  <li>Therefore, G has a clique of size k</li>
</ul>

<h2 id="3-correctness-justification">3. Correctness Justification</h2>

<h3 id="31-if-clique-has-a-solution-then-kite-has-a-solution">3.1 If Clique has a solution, then Kite has a solution</h3>

<p><strong>Given:</strong> Clique instance (G, k) has solution C (clique of size k in G).</p>

<p><strong>Construct Kite Solution:</strong></p>

<p><strong>Kite Construction:</strong></p>
<ul>
  <li>Clique part: Use all k vertices from C (the original clique)</li>
  <li>Tail part: Use the tail vertices t₁, t₂, …, tₖ</li>
  <li>Tail attachment: The tail attaches to any vertex v ∈ C via t₁ (since t₁ is connected to all vertices in V, including v)</li>
  <li>Total: 2k vertices ✓</li>
</ul>

<p><strong>Verify Satisfaction:</strong></p>
<ul>
  <li>Clique part has k vertices forming a clique: ✓ (C is a clique)</li>
  <li>Tail part has k vertices forming a path: ✓ (t₁-t₂-…-tₖ is a path)</li>
  <li>Tail attaches to exactly one vertex of the clique: ✓ (via t₁ connected to v)</li>
  <li>Total vertices: 2k = 2g ✓</li>
</ul>

<p><strong>Conclusion:</strong> Kite has a solution.</p>

<h3 id="32a-if-clique-does-not-have-a-solution-then-kite-has-no-solution">3.2a If Clique does not have a solution, then Kite has no solution</h3>

<p><strong>Given:</strong> Clique instance (G, k) has no solution (no clique of size k).</p>

<p><strong>Proof:</strong></p>

<p><strong>Assume:</strong> Kite instance (G’, k) has a solution (kite K with 2k vertices).</p>

<p><strong>Extract Clique:</strong></p>
<ul>
  <li>K has 2k vertices: k in clique part, k in tail part</li>
  <li>The tail vertices t₁, …, tₖ form a path (not a clique)</li>
  <li>Therefore, the clique part must consist entirely of k vertices from the original graph G</li>
  <li>These k vertices form a clique in G (since edges are preserved from G to G’)</li>
</ul>

<p><strong>Contradiction:</strong></p>
<ul>
  <li>If a kite exists, the clique part is a k-clique in G</li>
  <li>This contradicts the assumption that G has no k-clique</li>
</ul>

<p><strong>Conclusion:</strong> Kite has no solution.</p>

<h3 id="32b-if-kite-has-a-solution-then-clique-has-a-solution">3.2b If Kite has a solution, then Clique has a solution</h3>

<p><strong>Given:</strong> Kite instance (G’, k) has solution (kite K with 2k vertices).</p>

<p><strong>Extract Clique:</strong></p>
<ul>
  <li>K has 2k vertices: k in clique part, k in tail part</li>
  <li>The clique part consists of k vertices</li>
  <li>Since tail vertices form a path (not a clique), the clique part must consist of vertices from the original graph G</li>
  <li>These k vertices form a clique in G (since edges are preserved from G to G’)</li>
</ul>

<p><strong>Verify Satisfaction:</strong></p>

<p><strong>Clique Requirements:</strong></p>
<ul>
  <li>We have k vertices from G: ✓</li>
  <li>These k vertices form a clique: ✓ (they form the clique part of the kite)</li>
  <li>Therefore, G has a clique of size k</li>
</ul>

<p><strong>Key Insight:</strong></p>
<ul>
  <li>A kite requires exactly k vertices forming a clique</li>
  <li>The tail vertices form a path, not a clique</li>
  <li>Therefore, the clique part must come from the original graph G</li>
  <li>Any kite solution gives us a k-clique in G</li>
</ul>

<p><strong>Conclusion:</strong> The k vertices from the clique part form a clique of size k in G, so Clique has a solution.</p>

<h2 id="polynomial-time-analysis">Polynomial Time Analysis</h2>

<p><strong>Input Size:</strong></p>
<ul>
  <li>Clique: Graph G with n vertices and m edges, integer k</li>
  <li>Kite: Graph G’ with n + k + 1 vertices (original n + tail k + possibly u) and m + O(n + k) edges, goal g = k</li>
</ul>

<p><strong>Construction Time:</strong></p>
<ul>
  <li>Add tail vertices: O(k) time</li>
  <li>Connect tail as path: O(k) time</li>
  <li>Connect t₁ to all vertices in V: O(n) time</li>
  <li>Set g = k: O(1) time</li>
  <li>Total: O(n + k) time</li>
</ul>

<p><strong>Conclusion:</strong> Reduction is polynomial-time.</p>

<h2 id="summary">Summary</h2>

<p>We have shown:</p>
<ol>
  <li><strong>Kite ∈ NP</strong>: Solutions can be verified in polynomial time</li>
  <li><strong>Clique ≤ₚ Kite</strong>: Polynomial-time reduction exists</li>
  <li><strong>Correctness</strong>: Clique has solution ↔ Kite has solution</li>
</ol>

<p><strong>Therefore, Kite is NP-complete.</strong></p>

<h2 id="key-insights">Key Insights</h2>

<ol>
  <li><strong>Kite Structure</strong>: A kite combines a clique (k vertices) with a tail path (k vertices), totaling 2k vertices</li>
  <li><strong>Clique Extraction</strong>: The clique part of any kite must come from the original graph, since tail vertices form a path</li>
  <li><strong>Tail Attachment</strong>: The tail can attach to any vertex via t₁, which is connected to all original vertices</li>
  <li><strong>Preservation</strong>: The reduction preserves clique structure while adding the necessary tail structure</li>
</ol>

<h2 id="practice-questions">Practice Questions</h2>

<ol>
  <li><strong>Modify the reduction</strong> to use a different tail attachment strategy. What if we only connect t₁ to a subset of vertices?</li>
  <li><strong>Analyze alternative constructions:</strong> Could we use a shorter tail? What’s the minimum tail length needed?</li>
  <li><strong>Consider induced subgraphs:</strong> What if we require the kite to be an induced subgraph? Does the reduction still work?</li>
  <li><strong>Prove the reverse reduction:</strong> Can we reduce Kite to Clique? How?</li>
  <li><strong>Investigate special cases:</strong> For what graph classes is Kite polynomial-time solvable?</li>
</ol>

<hr />

<p>This reduction demonstrates how structural constraints (kite = clique + tail) can encode clique-finding problems, enabling reductions between graph structure problems.</p>]]></content><author><name></name></author><category term="Algorithms" /><category term="Complexity Theory" /><category term="NP-Hard" /><summary type="html"><![CDATA[A detailed proof showing how to reduce Clique to Kite, demonstrating that Kite is NP-complete.]]></summary></entry><entry><title type="html">Reduction: Clique to Maximum Common Subgraph</title><link href="https://robinali34.github.io/blog_algorithms//blog_algorithms/2025/11/22/reduction-clique-to-maximum-common-subgraph/" rel="alternate" type="text/html" title="Reduction: Clique to Maximum Common Subgraph" /><published>2025-11-22T00:00:00+00:00</published><updated>2025-11-22T00:00:00+00:00</updated><id>https://robinali34.github.io/blog_algorithms//blog_algorithms/2025/11/22/reduction-clique-to-maximum-common-subgraph</id><content type="html" xml:base="https://robinali34.github.io/blog_algorithms//blog_algorithms/2025/11/22/reduction-clique-to-maximum-common-subgraph/"><![CDATA[<h2 id="introduction">Introduction</h2>

<p>This post provides a detailed proof that the Maximum Common Subgraph problem is NP-complete by reducing from Clique. Maximum Common Subgraph asks for sets of nodes to delete from two graphs such that the remaining graphs are identical and each has at least b nodes.</p>

<h2 id="problem-definitions">Problem Definitions</h2>

<h3 id="maximum-common-subgraph-problem">Maximum Common Subgraph Problem</h3>

<p><strong>Input:</strong></p>
<ul>
  <li>Two graphs G₁ = (V₁, E₁) and G₂ = (V₂, E₂)</li>
  <li>A budget b ≥ 0</li>
</ul>

<p><strong>Output:</strong> YES if there exist two sets of nodes V₁’ ⊆ V₁ and V₂’ ⊆ V₂ whose deletion leaves at least b nodes in each graph, and makes the two graphs identical (isomorphic), NO otherwise.</p>

<p><strong>Note:</strong> After deleting V₁’ from G₁ and V₂’ from G₂, the remaining graphs must be isomorphic and each must have at least b vertices.</p>

<h3 id="clique-problem">Clique Problem</h3>

<p><strong>Input:</strong></p>
<ul>
  <li>An undirected graph G = (V, E)</li>
  <li>Integer k ≥ 1</li>
</ul>

<p><strong>Output:</strong> YES if G contains a clique of size k (set of k vertices, all pairwise adjacent), NO otherwise.</p>

<h2 id="1-np-completeness-proof-of-maximum-common-subgraph-solution-validation">1. NP-Completeness Proof of Maximum Common Subgraph: Solution Validation</h2>

<h3 id="maximum-common-subgraph--np">Maximum Common Subgraph ∈ NP</h3>

<p><strong>Verification Algorithm:</strong>
Given a candidate solution (sets V₁’ ⊆ V₁ and V₂’ ⊆ V₂):</p>
<ol>
  <li>
    <table>
      <tbody>
        <tr>
          <td>Check that</td>
          <td>V₁ \ V₁’</td>
          <td>≥ b: O(1) time</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>Check that</td>
          <td>V₂ \ V₂’</td>
          <td>≥ b: O(1) time</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>Construct remaining graphs G₁’ and G₂’ by deleting V₁’ and V₂’: O(n₁ + n₂ + m₁ + m₂) time</li>
  <li>Check that G₁’ and G₂’ are isomorphic: O(n²) time using graph isomorphism algorithms</li>
</ol>

<p><strong>Total Time:</strong> O(n²), which is polynomial in input size.</p>

<p><strong>Conclusion:</strong> Maximum Common Subgraph ∈ NP.</p>

<h2 id="2-reduce-clique-to-maximum-common-subgraph">2. Reduce Clique to Maximum Common Subgraph</h2>

<p><strong>Key Insight:</strong> Given a Clique instance, we can reduce it to Maximum Common Subgraph by setting G₁ = G (the original graph) and G₂ = K_k (the complete graph on k vertices). Then G has a k-clique if and only if we can delete nodes from G₁ to make it isomorphic to K_k, which means the remaining subgraph is a k-clique.</p>

<p><strong>Hint:</strong> If we set G₂ = K_k and b = k, then finding sets V₁’ and V₂’ such that the remaining graphs are identical means finding a subgraph of G₁ isomorphic to K_k. Since K_k is a complete graph on k vertices, this is exactly a k-clique.</p>

<h3 id="21-input-conversion">2.1 Input Conversion</h3>

<p>Given a Clique instance (G, k) where G = (V, E) with n vertices, we construct a Maximum Common Subgraph instance (G₁, G₂, b).</p>

<p><strong>Construction:</strong></p>

<p><strong>Step 1: Set First Graph</strong></p>
<ul>
  <li>G₁ = G (the original graph)</li>
</ul>

<p><strong>Step 2: Set Second Graph</strong></p>
<ul>
  <li>G₂ = K_k (complete graph on k vertices)</li>
  <li>V₂ = {1, 2, …, k}</li>
  <li>E₂ = {(i, j) : 1 ≤ i &lt; j ≤ k} (all pairs are adjacent)</li>
</ul>

<p><strong>Step 3: Set Budget</strong></p>
<ul>
  <li>b = k (we want at least k nodes remaining in each graph)</li>
</ul>

<p><strong>Step 4: Result</strong></p>
<ul>
  <li>Maximum Common Subgraph instance: (G₁, G₂, k) where G₁ = G and G₂ = K_k</li>
</ul>

<p><strong>Detailed Example:</strong></p>

<p>Consider Clique instance:</p>
<ul>
  <li>Graph G with vertices {1, 2, 3, 4}</li>
  <li>Edges: {(1,2), (1,3), (2,3), (2,4), (3,4)}</li>
  <li>k = 3 (want clique of size 3)</li>
</ul>

<p><strong>Transformation:</strong></p>
<ul>
  <li>G₁ = G (same graph)</li>
  <li>G₂ = K₃ (complete graph on 3 vertices)
    <ul>
      <li>Vertices: {a, b, c}</li>
      <li>Edges: {(a,b), (a,c), (b,c)}</li>
    </ul>
  </li>
  <li>b = 3</li>
</ul>

<p><strong>Maximum Common Subgraph instance:</strong> (G₁, K₃, 3)</p>

<h3 id="22-output-conversion">2.2 Output Conversion</h3>

<p><strong>Given:</strong> Maximum Common Subgraph solution (sets V₁’ ⊆ V₁ and V₂’ ⊆ V₂ such that after deletion, graphs are identical and each has at least b = k nodes)</p>

<p><strong>Extract Clique:</strong></p>
<ul>
  <li>Since G₂ = K_k has exactly k vertices, we must delete V₂’ = ∅ (delete nothing)</li>
  <li>The remaining graph G₁’ (after deleting V₁’) must be isomorphic to K_k</li>
  <li>Since K_k is a complete graph on k vertices, G₁’ is a k-clique</li>
  <li>The vertices of G₁’ form a clique of size k in G</li>
</ul>

<p><strong>Verify Satisfaction:</strong></p>
<ul>
  <li>G₁’ has k vertices: ✓ (since isomorphic to K_k)</li>
  <li>All pairs of vertices in G₁’ are adjacent: ✓ (since G₁’ is isomorphic to K_k, which is complete)</li>
  <li>Therefore, G₁’ is a clique of size k in G</li>
</ul>

<h2 id="3-correctness-justification">3. Correctness Justification</h2>

<h3 id="31-if-clique-has-a-solution-then-maximum-common-subgraph-has-a-solution">3.1 If Clique has a solution, then Maximum Common Subgraph has a solution</h3>

<p><strong>Given:</strong> Clique instance (G, k) has solution C (clique of size k).</p>

<p><strong>Construct Maximum Common Subgraph Solution:</strong></p>
<ul>
  <li>Let G₁’ be the subgraph of G₁ = G induced by vertices in C</li>
  <li>Since C is a clique, G₁’ is isomorphic to K_k</li>
  <li>Set V₁’ = V₁ \ C (delete all vertices not in the clique)</li>
  <li>Set V₂’ = ∅ (delete nothing from K_k, since it already has exactly k vertices)</li>
  <li>After deletion:
    <ul>
      <li>G₁’ has k vertices and is isomorphic to K_k</li>
      <li>G₂’ = G₂ = K_k (unchanged)</li>
      <li>Both graphs are isomorphic (both are K_k)</li>
    </ul>
  </li>
</ul>

<p><strong>Verify Satisfaction:</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">|V₁ \ V₁'|</code> = <code class="language-plaintext highlighter-rouge">|C|</code> = k ≥ b = k: ✓</li>
  <li><code class="language-plaintext highlighter-rouge">|V₂ \ V₂'|</code> = <code class="language-plaintext highlighter-rouge">|V₂|</code> = k ≥ b = k: ✓</li>
  <li>G₁’ is isomorphic to G₂’: ✓ (both are K_k)</li>
  <li>Therefore, the solution is valid</li>
</ul>

<p><strong>Conclusion:</strong> Maximum Common Subgraph has a solution.</p>

<h3 id="32a-if-clique-does-not-have-a-solution-then-maximum-common-subgraph-has-no-solution">3.2a If Clique does not have a solution, then Maximum Common Subgraph has no solution</h3>

<p><strong>Given:</strong> Clique instance (G, k) has no solution (no clique of size k).</p>

<p><strong>Proof:</strong></p>

<p><strong>Assume:</strong> Maximum Common Subgraph instance (G₁, G₂, k) where G₁ = G and G₂ = K_k has a solution (sets V₁’, V₂’).</p>

<p><strong>Extract Clique:</strong></p>
<ul>
  <li>Since G₂ = K_k has exactly k vertices, to have at least k vertices remaining, we must have V₂’ = ∅</li>
  <li>Therefore, G₂’ = G₂ = K_k (unchanged)</li>
  <li>G₁’ (after deleting V₁’) must be isomorphic to G₂’ = K_k</li>
  <li>Since G₁’ is isomorphic to K_k, it is a complete graph on k vertices</li>
  <li>Therefore, G₁’ is a k-clique in G₁ = G</li>
</ul>

<p><strong>Contradiction:</strong></p>
<ul>
  <li>G₁’ is a k-clique in G</li>
  <li>This contradicts the assumption that G has no k-clique</li>
</ul>

<p><strong>Conclusion:</strong> Maximum Common Subgraph has no solution.</p>

<h3 id="32b-if-maximum-common-subgraph-has-a-solution-then-clique-has-a-solution">3.2b If Maximum Common Subgraph has a solution, then Clique has a solution</h3>

<p><strong>Given:</strong> Maximum Common Subgraph instance (G₁, G₂, k) where G₁ = G and G₂ = K_k has solution (sets V₁’, V₂’).</p>

<p><strong>Extract Clique:</strong></p>
<ul>
  <li>Since G₂ = K_k has exactly k vertices, to have at least k vertices remaining, we must have V₂’ = ∅</li>
  <li>Therefore, G₂’ = G₂ = K_k</li>
  <li>G₁’ (after deleting V₁’) must be isomorphic to G₂’ = K_k</li>
  <li>Since G₁’ is isomorphic to K_k, it is a complete graph on k vertices</li>
  <li>The vertices of G₁’ form a clique of size k in G₁ = G</li>
</ul>

<p><strong>Verify Satisfaction:</strong></p>

<p><strong>Clique Requirements:</strong></p>
<ul>
  <li>G₁’ has exactly k vertices: ✓ (since isomorphic to K_k)</li>
  <li>All pairs of vertices in G₁’ are adjacent: ✓ (since G₁’ is isomorphic to K_k, which is complete)</li>
  <li>Therefore, G₁’ is a clique of size k in G</li>
</ul>

<p><strong>Key Insight:</strong></p>
<ul>
  <li>Setting G₂ = K_k forces the common subgraph to be K_k</li>
  <li>Finding a subgraph of G₁ isomorphic to K_k is exactly finding a k-clique</li>
  <li>The budget b = k ensures we keep exactly k vertices (since K_k has k vertices)</li>
  <li>Therefore, any solution to Maximum Common Subgraph gives us a k-clique</li>
</ul>

<p><strong>Conclusion:</strong> The subgraph G₁’ forms a clique of size k in G, so Clique has a solution.</p>

<h2 id="polynomial-time-analysis">Polynomial Time Analysis</h2>

<p><strong>Input Size:</strong></p>
<ul>
  <li>Clique: Graph G with n vertices and m edges, integer k</li>
  <li>Maximum Common Subgraph: Graph G₁ with n vertices and m edges, graph G₂ = K_k with k vertices and k(k-1)/2 edges, budget b = k</li>
</ul>

<p><strong>Construction Time:</strong></p>
<ul>
  <li>Set G₁ = G: O(1) time</li>
  <li>Create K_k: O(k²) time (k vertices, k(k-1)/2 edges)</li>
  <li>Set b = k: O(1) time</li>
  <li>Total: O(k²) time</li>
</ul>

<p><strong>Conclusion:</strong> Reduction is polynomial-time.</p>

<h2 id="summary">Summary</h2>

<p>We have shown:</p>
<ol>
  <li><strong>Maximum Common Subgraph ∈ NP</strong>: Solutions can be verified in polynomial time</li>
  <li><strong>Clique ≤ₚ Maximum Common Subgraph</strong>: Polynomial-time reduction exists</li>
  <li><strong>Correctness</strong>: Clique has solution ↔ Maximum Common Subgraph has solution</li>
</ol>

<p><strong>Therefore, Maximum Common Subgraph is NP-complete.</strong></p>

<h2 id="key-insights">Key Insights</h2>

<ol>
  <li><strong>Pattern Graph</strong>: Using K_k as G₂ forces the common subgraph to be a k-clique</li>
  <li><strong>Isomorphism Constraint</strong>: Requiring the graphs to be identical after deletion forces G₁’ to be isomorphic to K_k</li>
  <li><strong>Budget Constraint</strong>: Setting b = k ensures we keep exactly k vertices</li>
  <li><strong>Clique Characterization</strong>: A subgraph isomorphic to K_k is exactly a k-clique</li>
  <li><strong>Preservation</strong>: The reduction preserves the clique structure through isomorphism requirements</li>
</ol>

<h2 id="practice-questions">Practice Questions</h2>

<ol>
  <li><strong>Modify the reduction</strong> to reduce Independent Set to Maximum Common Subgraph. What would you use as G₂?</li>
  <li><strong>Extend the reduction</strong> to handle weighted graphs. How would you modify the problem?</li>
  <li><strong>Consider the optimization version:</strong> How would you reduce the optimization version of Clique to Maximum Common Subgraph?</li>
  <li><strong>Prove the reverse reduction:</strong> Can we reduce Maximum Common Subgraph to Clique? How?</li>
  <li><strong>Investigate special cases:</strong> For what graph classes is Maximum Common Subgraph polynomial-time solvable?</li>
</ol>

<hr />

<p>This reduction demonstrates how graph isomorphism constraints can encode clique-finding requirements, enabling reductions between subgraph matching and clique problems.</p>]]></content><author><name></name></author><category term="Algorithms" /><category term="Complexity Theory" /><category term="NP-Hard" /><summary type="html"><![CDATA[A detailed proof showing how to reduce Clique to Maximum Common Subgraph, demonstrating that Maximum Common Subgraph is NP-complete.]]></summary></entry><entry><title type="html">Reduction: Clique to Subgraph Isomorphism</title><link href="https://robinali34.github.io/blog_algorithms//blog_algorithms/2025/11/22/reduction-clique-to-subgraph-isomorphism/" rel="alternate" type="text/html" title="Reduction: Clique to Subgraph Isomorphism" /><published>2025-11-22T00:00:00+00:00</published><updated>2025-11-22T00:00:00+00:00</updated><id>https://robinali34.github.io/blog_algorithms//blog_algorithms/2025/11/22/reduction-clique-to-subgraph-isomorphism</id><content type="html" xml:base="https://robinali34.github.io/blog_algorithms//blog_algorithms/2025/11/22/reduction-clique-to-subgraph-isomorphism/"><![CDATA[<h2 id="introduction">Introduction</h2>

<p>This post provides a detailed proof that the Subgraph Isomorphism problem is NP-complete by reducing from Clique. Subgraph Isomorphism asks whether one graph is a subgraph of another (obtained by deleting certain vertices and edges), and if so, returns the corresponding vertex mapping.</p>

<h2 id="problem-definitions">Problem Definitions</h2>

<h3 id="subgraph-isomorphism-problem">Subgraph Isomorphism Problem</h3>

<p><strong>Input:</strong></p>
<ul>
  <li>Two undirected graphs G = (V_G, E_G) and H = (V_H, E_H)</li>
</ul>

<p><strong>Output:</strong> YES if G is a subgraph of H (i.e., by deleting certain vertices and edges of H, we obtain a graph that is, up to renaming of vertices, identical to G), and if so, return the corresponding mapping of V(G) into V(H). NO otherwise.</p>

<p><strong>Note:</strong> This means determining whether there exists a subgraph H’ of H such that H’ is isomorphic to G, and providing the isomorphism mapping f: V_G → V_H’ ⊆ V_H.</p>

<h3 id="clique-problem">Clique Problem</h3>

<p><strong>Input:</strong></p>
<ul>
  <li>An undirected graph G = (V, E)</li>
  <li>Integer k ≥ 1</li>
</ul>

<p><strong>Output:</strong> YES if G contains a clique of size k (set of k vertices, all pairwise adjacent), NO otherwise.</p>

<h2 id="1-np-completeness-proof-of-subgraph-isomorphism-solution-validation">1. NP-Completeness Proof of Subgraph Isomorphism: Solution Validation</h2>

<h3 id="subgraph-isomorphism--np">Subgraph Isomorphism ∈ NP</h3>

<p><strong>Verification Algorithm:</strong>
Given a candidate solution (mapping f: V_G → V_H):</p>
<ol>
  <li>
    <table>
      <tbody>
        <tr>
          <td>Check that f is injective (one-to-one): O(</td>
          <td>V_G</td>
          <td>) time</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>Check that f maps V_G into V_H: O(</td>
          <td>V_G</td>
          <td>) time</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>For each edge (u, v) ∈ E_G:
    <ul>
      <li>Check that (f(u), f(v)) ∈ E_H: O(1) time</li>
    </ul>
  </li>
  <li>Verify that the subgraph H’ induced by f(V_G) is isomorphic to G:
    <ul>
      <li>
        <table>
          <tbody>
            <tr>
              <td>Check that for each edge (u, v) ∈ E_G, (f(u), f(v)) ∈ E_H: O(</td>
              <td>E_G</td>
              <td>) time</td>
            </tr>
          </tbody>
        </table>
      </li>
      <li>
        <table>
          <tbody>
            <tr>
              <td>Check that for each non-edge (u, v) ∉ E_G, (f(u), f(v)) ∉ E_H: O(</td>
              <td>V_G</td>
              <td>²) time</td>
            </tr>
          </tbody>
        </table>
      </li>
    </ul>
  </li>
</ol>

<table>
  <tbody>
    <tr>
      <td><strong>Total Time:</strong> O(</td>
      <td>V_G</td>
      <td>²), which is polynomial in input size.</td>
    </tr>
  </tbody>
</table>

<p><strong>Conclusion:</strong> Subgraph Isomorphism ∈ NP.</p>

<h2 id="2-reduce-clique-to-subgraph-isomorphism">2. Reduce Clique to Subgraph Isomorphism</h2>

<p><strong>Key Insight:</strong> Given a Clique instance, we can reduce it to Subgraph Isomorphism by setting the pattern graph G to be a complete graph on k vertices (K_k), and the host graph H to be the original graph. Then the original graph contains a clique of size k if and only if K_k is a subgraph of H.</p>

<p><strong>Hint:</strong> A clique of size k is exactly a complete graph on k vertices. Therefore, finding a k-clique in H is equivalent to determining whether K_k (as graph G) is a subgraph of H.</p>

<h3 id="21-input-conversion">2.1 Input Conversion</h3>

<p>Given a Clique instance (H, k) where H = (V_H, E_H) is the original graph and we want a clique of size k, we construct a Subgraph Isomorphism instance (G, H).</p>

<p><strong>Construction:</strong></p>

<p><strong>Step 1: Use Original Graph as Host</strong></p>
<ul>
  <li>H remains the same (the original graph)</li>
</ul>

<p><strong>Step 2: Create Pattern Graph</strong></p>
<ul>
  <li>G = K_k (complete graph on k vertices)</li>
  <li>V_G = {1, 2, …, k}</li>
  <li>E_G = {(i, j) : 1 ≤ i &lt; j ≤ k} (all pairs of vertices are adjacent)</li>
</ul>

<p><strong>Step 3: Result</strong></p>
<ul>
  <li>Subgraph Isomorphism instance: (G, H) where G = K_k and H is the original graph</li>
</ul>

<p><strong>Detailed Example:</strong></p>

<p>Consider Clique instance:</p>
<ul>
  <li>Graph H with vertices {1, 2, 3, 4}</li>
  <li>Edges: {(1,2), (1,3), (2,3), (2,4), (3,4)}</li>
  <li>k = 3 (want clique of size 3)</li>
</ul>

<p><strong>Transformation:</strong></p>
<ul>
  <li>H remains the same (host graph)</li>
  <li>G = K₃ (pattern graph - complete graph on 3 vertices)
    <ul>
      <li>Vertices: {a, b, c}</li>
      <li>Edges: {(a,b), (a,c), (b,c)}</li>
    </ul>
  </li>
</ul>

<p><strong>Subgraph Isomorphism instance:</strong> (G, H) where G = K₃</p>

<p><strong>Question:</strong> Is G (K₃) a subgraph of H? This is equivalent to asking if H contains a 3-clique.</p>

<h3 id="22-output-conversion">2.2 Output Conversion</h3>

<p><strong>Given:</strong> Subgraph Isomorphism solution (mapping f: V_G → V_H showing that G = K_k is a subgraph of H)</p>

<p><strong>Extract Clique:</strong></p>
<ul>
  <li>The image f(V_G) = {f(1), f(2), …, f(k)} forms a set of k vertices in H</li>
  <li>Since G = K_k is complete, for every edge (i, j) in G, we have (f(i), f(j)) ∈ E_H</li>
  <li>Therefore, all pairs of vertices in f(V_G) are adjacent in H</li>
  <li>f(V_G) is a k-clique in H</li>
</ul>

<p><strong>Verify Satisfaction:</strong></p>
<ul>
  <li>
    <table>
      <tbody>
        <tr>
          <td>f(V_G) has k vertices (since f is injective and</td>
          <td>V_G</td>
          <td>= k)</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>All pairs of vertices in f(V_G) are adjacent in H (since G is complete and f preserves edges)</li>
  <li>Therefore, f(V_G) is a clique of size k in H</li>
</ul>

<h2 id="3-correctness-justification">3. Correctness Justification</h2>

<h3 id="31-if-clique-has-a-solution-then-subgraph-isomorphism-has-a-solution">3.1 If Clique has a solution, then Subgraph Isomorphism has a solution</h3>

<p><strong>Given:</strong> Clique instance (G, k) has solution C (clique of size k).</p>

<p><strong>Construct Subgraph Isomorphism Solution:</strong></p>
<ul>
  <li>Let C = {v₁, v₂, …, vₖ} be the clique vertices in H</li>
  <li>Define mapping f: V_G → V_H where V_G = {1, 2, …, k} (vertices of K_k)</li>
  <li>Set f(i) = vᵢ for i = 1, …, k</li>
  <li>Since C is a clique, for every edge (i, j) in G = K_k, we have (f(i), f(j)) = (vᵢ, vⱼ) ∈ E_H</li>
  <li>Therefore, f shows that G = K_k is a subgraph of H</li>
</ul>

<p><strong>Verify Satisfaction:</strong></p>
<ul>
  <li>f is injective: ✓ (maps distinct vertices to distinct vertices)</li>
  <li>f maps V_G into V_H: ✓ (C ⊆ V_H)</li>
  <li>For each edge (i, j) ∈ E_G: (f(i), f(j)) ∈ E_H: ✓ (since C is a clique)</li>
  <li>Therefore, G = K_k is a subgraph of H with mapping f</li>
</ul>

<p><strong>Conclusion:</strong> Subgraph Isomorphism has a solution.</p>

<h3 id="32a-if-clique-does-not-have-a-solution-then-subgraph-isomorphism-has-no-solution">3.2a If Clique does not have a solution, then Subgraph Isomorphism has no solution</h3>

<p><strong>Given:</strong> Clique instance (G, k) has no solution (no clique of size k).</p>

<p><strong>Proof:</strong></p>

<p><strong>Assume:</strong> Subgraph Isomorphism instance (G, H) where G = K_k has a solution (mapping f showing G is a subgraph of H).</p>

<p><strong>Extract Clique:</strong></p>
<ul>
  <li>f(V_G) = {f(1), …, f(k)} has k vertices in H (since f is injective)</li>
  <li>Since G = K_k is complete, for every pair (i, j) with i &lt; j, we have (f(i), f(j)) ∈ E_H</li>
  <li>Therefore, f(V_G) forms a clique of size k in H</li>
</ul>

<p><strong>Contradiction:</strong></p>
<ul>
  <li>f(V_G) is a clique of size k in H</li>
  <li>This contradicts the assumption that H has no clique of size k</li>
</ul>

<p><strong>Conclusion:</strong> Subgraph Isomorphism has no solution.</p>

<h3 id="32b-if-subgraph-isomorphism-has-a-solution-then-clique-has-a-solution">3.2b If Subgraph Isomorphism has a solution, then Clique has a solution</h3>

<p><strong>Given:</strong> Subgraph Isomorphism instance (G, H) where G = K_k has solution (mapping f: V_G → V_H).</p>

<p><strong>Extract Clique:</strong></p>
<ul>
  <li>Let C = f(V_G) = {f(1), f(2), …, f(k)} be the image of the mapping</li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>C has k vertices (since f is injective and</td>
          <td>V_G</td>
          <td>= k)</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>Since G = K_k is complete, for every edge (i, j) in G, we have (f(i), f(j)) ∈ E_H</li>
  <li>Therefore, all pairs of vertices in C are adjacent in H</li>
</ul>

<p><strong>Verify Satisfaction:</strong></p>

<p><strong>Clique Requirements:</strong></p>
<ul>
  <li>C has exactly k vertices: ✓ (by injectivity of f)</li>
  <li>All pairs of vertices in C are adjacent in H: ✓ (since G is complete and f preserves edges)</li>
  <li>Therefore, C is a clique of size k in H</li>
</ul>

<p><strong>Key Insight:</strong></p>
<ul>
  <li>A complete graph on k vertices (K_k) is exactly a clique of size k</li>
  <li>Determining whether K_k is a subgraph of H is equivalent to finding a k-clique in H</li>
  <li>The mapping f provides the vertex correspondence showing which k vertices form the clique</li>
  <li>Therefore, any solution to Subgraph Isomorphism gives us a clique of size k and its vertex mapping</li>
</ul>

<p><strong>Conclusion:</strong> The set C forms a clique of size k in G, so Clique has a solution.</p>

<h2 id="polynomial-time-analysis">Polynomial Time Analysis</h2>

<p><strong>Input Size:</strong></p>
<ul>
  <li>Clique: Graph H with n vertices and m edges, integer k</li>
  <li>Subgraph Isomorphism: Graph H with n vertices and m edges, graph G = K_k with k vertices and k(k-1)/2 edges</li>
</ul>

<p><strong>Construction Time:</strong></p>
<ul>
  <li>Use graph H as is: O(1) time</li>
  <li>Create K_k: O(k²) time (k vertices, k(k-1)/2 edges)</li>
  <li>Total: O(k²) time</li>
</ul>

<p><strong>Conclusion:</strong> Reduction is polynomial-time.</p>

<h2 id="summary">Summary</h2>

<p>We have shown:</p>
<ol>
  <li><strong>Subgraph Isomorphism ∈ NP</strong>: Solutions can be verified in polynomial time</li>
  <li><strong>Clique ≤ₚ Subgraph Isomorphism</strong>: Polynomial-time reduction exists</li>
  <li><strong>Correctness</strong>: Clique has solution ↔ Subgraph Isomorphism has solution</li>
</ol>

<p><strong>Therefore, Subgraph Isomorphism is NP-complete.</strong></p>

<h2 id="key-insights">Key Insights</h2>

<ol>
  <li><strong>Complete Graph Pattern</strong>: Using K_k as the pattern graph captures the clique structure</li>
  <li><strong>Isomorphism Equivalence</strong>: A clique is exactly a complete graph, so finding a subgraph isomorphic to K_k is equivalent to finding a clique</li>
  <li><strong>Preservation</strong>: The reduction preserves the clique structure through isomorphism</li>
  <li><strong>Pattern Construction</strong>: The pattern graph H = K_k encodes the clique requirement</li>
</ol>

<h2 id="practice-questions">Practice Questions</h2>

<ol>
  <li><strong>Modify the reduction</strong> to reduce Independent Set to Subgraph Isomorphism. What pattern graph would you use?</li>
  <li><strong>Extend the reduction</strong> to reduce k-Clique to Subgraph Isomorphism for fixed k. Does the complexity change?</li>
  <li><strong>Consider induced subgraphs:</strong> What if we require G’ to be an induced subgraph? Does the reduction still work?</li>
  <li><strong>Prove the reverse reduction:</strong> Can we reduce Subgraph Isomorphism to Clique? How?</li>
  <li><strong>Investigate special cases:</strong> For what classes of pattern graphs H is Subgraph Isomorphism polynomial-time solvable?</li>
</ol>

<hr />

<p>This reduction demonstrates how pattern matching (subgraph isomorphism) can capture structural properties (cliques), enabling reductions between graph problems.</p>]]></content><author><name></name></author><category term="Algorithms" /><category term="Complexity Theory" /><category term="NP-Hard" /><summary type="html"><![CDATA[A detailed proof showing how to reduce Clique to Subgraph Isomorphism, demonstrating that Subgraph Isomorphism is NP-complete.]]></summary></entry><entry><title type="html">Reduction: Independent Set to Clique + Independent Set</title><link href="https://robinali34.github.io/blog_algorithms//blog_algorithms/2025/11/22/reduction-independent-set-to-clique-independent-set/" rel="alternate" type="text/html" title="Reduction: Independent Set to Clique + Independent Set" /><published>2025-11-22T00:00:00+00:00</published><updated>2025-11-22T00:00:00+00:00</updated><id>https://robinali34.github.io/blog_algorithms//blog_algorithms/2025/11/22/reduction-independent-set-to-clique-independent-set</id><content type="html" xml:base="https://robinali34.github.io/blog_algorithms//blog_algorithms/2025/11/22/reduction-independent-set-to-clique-independent-set/"><![CDATA[<h2 id="introduction">Introduction</h2>

<p>This post provides a detailed proof that the Clique + Independent Set problem is NP-complete by reducing from Independent Set. The problem asks whether a graph contains both a clique of size k and an independent set of size k simultaneously.</p>

<h2 id="problem-definitions">Problem Definitions</h2>

<h3 id="clique--independent-set-problem">Clique + Independent Set Problem</h3>

<p><strong>Input:</strong></p>
<ul>
  <li>An undirected graph G = (V, E)</li>
  <li>An integer k ≥ 1</li>
</ul>

<p><strong>Output:</strong> YES if G contains both:</p>
<ul>
  <li>A clique of size k (set of k vertices, all pairwise adjacent)</li>
  <li>An independent set of size k (set of k vertices, no two adjacent)</li>
</ul>

<p>NO otherwise.</p>

<p><strong>Note:</strong> The problem requires returning both a clique of size k and an independent set of size k, provided both exist. The clique and independent set may share vertices.</p>

<h3 id="independent-set-problem">Independent Set Problem</h3>

<p><strong>Input:</strong></p>
<ul>
  <li>An undirected graph G = (V, E)</li>
  <li>Integer k ≥ 1</li>
</ul>

<p><strong>Output:</strong> YES if G contains an independent set of size k, NO otherwise.</p>

<h2 id="1-np-completeness-proof-of-clique--independent-set-solution-validation">1. NP-Completeness Proof of Clique + Independent Set: Solution Validation</h2>

<h3 id="clique--independent-set--np">Clique + Independent Set ∈ NP</h3>

<p><strong>Verification Algorithm:</strong>
Given a candidate solution (clique C of size k, independent set I of size k):</p>
<ol>
  <li>Check that C has exactly k vertices: O(1) time</li>
  <li>Check that all pairs in C are adjacent: O(k²) time</li>
  <li>Check that I has exactly k vertices: O(1) time</li>
  <li>Check that no two vertices in I are adjacent: O(k²) time</li>
</ol>

<p><strong>Total Time:</strong> O(k²), which is polynomial in input size.</p>

<p><strong>Conclusion:</strong> Clique + Independent Set ∈ NP.</p>

<h2 id="2-reduce-independent-set-to-clique--independent-set">2. Reduce Independent Set to Clique + Independent Set</h2>

<p><strong>Key Insight:</strong> Given an Independent Set instance, we can reduce it to Clique + Independent Set by adding k isolated vertices to the graph. This ensures a k-independent set always exists (using the isolated vertices), reducing the problem to finding a k-clique. However, a simpler approach is to reduce from Clique by ensuring a k-independent set always exists through graph modification.</p>

<p><strong>Hint:</strong> We can reduce from Clique by adding k isolated vertices, ensuring a k-independent set always exists. Then finding both a k-clique and k-independent set reduces to finding a k-clique. Alternatively, we can reduce from Independent Set by ensuring a k-clique always exists (e.g., by adding a k-clique disconnected from the rest).</p>

<h3 id="21-input-conversion">2.1 Input Conversion</h3>

<p>Given an Independent Set instance (G, k) where G = (V, E) and we want an independent set of size k, we construct a Clique + Independent Set instance (G’, k’).</p>

<p><strong>Construction:</strong></p>

<p><strong>Step 1: Add Disjoint Clique</strong></p>
<ul>
  <li>Add k new vertices: v₁, v₂, …, vₖ</li>
  <li>Connect them to form a clique: add all edges (vᵢ, vⱼ) for i &lt; j</li>
  <li>This clique is disjoint from the original graph (no edges between new and old vertices)</li>
</ul>

<p><strong>Step 2: Set Parameter</strong></p>
<ul>
  <li>k’ = k (we want both a clique of size k and an independent set of size k)</li>
</ul>

<p><strong>Step 3: Result</strong></p>
<ul>
  <li>Clique + Independent Set instance: (G’, k)</li>
</ul>

<p><strong>Detailed Example:</strong></p>

<p>Consider Independent Set instance:</p>
<ul>
  <li>Graph G with vertices {1, 2, 3, 4}</li>
  <li>Edges: {(1,2), (2,3), (3,4)}</li>
  <li>k = 2 (want independent set of size 2)</li>
</ul>

<p><strong>Transformation:</strong></p>
<ul>
  <li>Add vertices: {5, 6}</li>
  <li>Add clique edges: {(5,6)}</li>
  <li>G’ has vertices {1, 2, 3, 4, 5, 6}</li>
  <li>G’ has edges: {(1,2), (2,3), (3,4), (5,6)}</li>
  <li>k’ = 2</li>
</ul>

<p><strong>Clique + Independent Set instance:</strong> (G’, 2)</p>

<p><strong>Note:</strong> The clique {5, 6} always exists. Finding both a 2-clique and 2-independent set reduces to finding a 2-independent set in the original graph.</p>

<h3 id="22-output-conversion">2.2 Output Conversion</h3>

<p><strong>Given:</strong> Clique + Independent Set solution (clique C of size k, independent set I of size k)</p>

<p><strong>Extract Independent Set:</strong></p>
<ul>
  <li>The clique C must be the added clique {v₁, …, vₖ} (since it’s disjoint and always exists)</li>
  <li>Use the independent set I</li>
  <li>I must come from the original graph G (since the added clique vertices are all connected to each other)</li>
  <li>I is an independent set of size k in G’ that doesn’t use the added clique vertices</li>
  <li>Therefore, I is an independent set of size k in the original graph G</li>
</ul>

<p><strong>Verify Satisfaction:</strong></p>
<ul>
  <li>I has k vertices</li>
  <li>No two vertices in I are adjacent (by definition of independent set)</li>
  <li>I uses only vertices from the original graph G</li>
  <li>Therefore, I is an independent set of size k in the original graph G</li>
</ul>

<h2 id="3-correctness-justification">3. Correctness Justification</h2>

<h3 id="31-if-independent-set-has-a-solution-then-clique--independent-set-has-a-solution">3.1 If Independent Set has a solution, then Clique + Independent Set has a solution</h3>

<p><strong>Given:</strong> Independent Set instance (G, k) has solution I (independent set of size k).</p>

<p><strong>Construct Clique + Independent Set Solution:</strong></p>
<ul>
  <li>Clique C: Use the added clique {v₁, v₂, …, vₖ} (always exists, size k)</li>
  <li>Independent set I: Use the given independent set of size k from G</li>
</ul>

<p><strong>Verify Satisfaction:</strong></p>
<ul>
  <li>C has size k: ✓ (the added clique)</li>
  <li>C is a clique: ✓ (all pairs in {v₁, …, vₖ} are adjacent)</li>
  <li>I has size k: ✓ (by assumption)</li>
  <li>I is an independent set: ✓ (by assumption)</li>
  <li>I uses vertices from G, which are disjoint from the clique vertices</li>
  <li>Therefore, (C, I) is a valid solution</li>
</ul>

<p><strong>Conclusion:</strong> Clique + Independent Set has a solution.</p>

<h3 id="32a-if-independent-set-does-not-have-a-solution-then-clique--independent-set-has-no-solution">3.2a If Independent Set does not have a solution, then Clique + Independent Set has no solution</h3>

<p><strong>Given:</strong> Independent Set instance (G, k) has no solution (no independent set of size k).</p>

<p><strong>Proof:</strong></p>

<p><strong>Assume:</strong> Clique + Independent Set instance (G’, k) has a solution (C, I).</p>

<p><strong>Extract Independent Set:</strong></p>
<ul>
  <li>The clique C must be the added clique {v₁, …, vₖ} (since it’s the only k-clique guaranteed to exist)</li>
  <li>Use independent set I from the solution</li>
  <li>I has size k (by assumption)</li>
  <li>I must use vertices from the original graph G (since the added clique vertices form a clique and can’t be in an independent set together)</li>
  <li>I is an independent set in G’ that uses only vertices from G</li>
  <li>Therefore, I is an independent set of size k in G</li>
</ul>

<p><strong>Contradiction:</strong></p>
<ul>
  <li>I is an independent set of size k in G</li>
  <li>This contradicts the assumption that G has no independent set of size k</li>
</ul>

<p><strong>Conclusion:</strong> Clique + Independent Set has no solution.</p>

<h3 id="32b-if-clique--independent-set-has-a-solution-then-independent-set-has-a-solution">3.2b If Clique + Independent Set has a solution, then Independent Set has a solution</h3>

<p><strong>Given:</strong> Clique + Independent Set instance (G’, k) has solution (C, I).</p>

<p><strong>Extract Independent Set:</strong></p>
<ul>
  <li>The clique C is the added clique {v₁, …, vₖ}</li>
  <li>Use independent set I</li>
  <li>I has size k (by assumption)</li>
  <li>I must use vertices from the original graph G (since the added clique vertices are all connected)</li>
  <li>I is an independent set in G’ that uses only vertices from G</li>
  <li>Therefore, I is an independent set of size k in G</li>
</ul>

<p><strong>Verify Satisfaction:</strong></p>

<p><strong>Independent Set Requirements:</strong></p>
<ul>
  <li>I has exactly k vertices: ✓ (by assumption)</li>
  <li>No two vertices in I are adjacent: ✓ (by definition of independent set)</li>
  <li>I uses only vertices from G: ✓ (since added clique vertices can’t be in I together)</li>
  <li>Therefore, I is an independent set of size k in G</li>
</ul>

<p><strong>Key Insight:</strong></p>
<ul>
  <li>By adding a disjoint k-clique, we ensure a k-clique always exists</li>
  <li>The problem reduces to finding a k-independent set in the original graph</li>
  <li>The added clique doesn’t interfere with finding an independent set since it’s disjoint</li>
  <li>Therefore, any solution to Clique + Independent Set gives us an independent set of size k</li>
</ul>

<p><strong>Conclusion:</strong> The independent set I satisfies all requirements, so Independent Set has a solution.</p>

<h2 id="polynomial-time-analysis">Polynomial Time Analysis</h2>

<p><strong>Input Size:</strong></p>
<ul>
  <li>Independent Set: Graph G with n vertices and m edges, integer k</li>
  <li>Clique + Independent Set: Graph G’ with n + k vertices and m + k(k-1)/2 edges, integer k</li>
</ul>

<p><strong>Construction Time:</strong></p>
<ul>
  <li>Add k vertices: O(k) time</li>
  <li>Add clique edges: O(k²) time</li>
  <li>Set k’ = k: O(1) time</li>
  <li>Total: O(n + m + k²) time</li>
</ul>

<p><strong>Conclusion:</strong> Reduction is polynomial-time.</p>

<h2 id="summary">Summary</h2>

<p>We have shown:</p>
<ol>
  <li><strong>Clique + Independent Set ∈ NP</strong>: Solutions can be verified in polynomial time</li>
  <li><strong>Independent Set ≤ₚ Clique + Independent Set</strong>: Polynomial-time reduction exists</li>
  <li><strong>Correctness</strong>: Independent Set has solution ↔ Clique + Independent Set has solution</li>
</ol>

<p><strong>Therefore, Clique + Independent Set is NP-complete.</strong></p>

<h2 id="key-insights">Key Insights</h2>

<ol>
  <li><strong>Disjoint Clique Addition</strong>: Adding a disjoint k-clique ensures a k-clique always exists</li>
  <li><strong>Problem Reduction</strong>: With a guaranteed k-clique, the problem reduces to finding a k-independent set</li>
  <li><strong>Preservation</strong>: The reduction preserves the core independent set structure</li>
  <li><strong>Disjoint Construction</strong>: Making the added clique disjoint ensures it doesn’t interfere with finding an independent set</li>
</ol>

<h2 id="practice-questions">Practice Questions</h2>

<ol>
  <li><strong>Modify the reduction</strong> to reduce Clique to Clique + Independent Set. How would you do it?</li>
  <li><strong>Analyze the case</strong> when k’ &gt; 1 and l’ &gt; 1. Is the problem still NP-complete?</li>
  <li><strong>Consider disjoint versions:</strong> What if the clique and independent set must be disjoint?</li>
  <li><strong>Prove the reverse reduction:</strong> Can we reduce Clique + Independent Set to Independent Set? How?</li>
  <li><strong>Investigate parameterized complexity:</strong> For what values of k’ and l’ is the problem polynomial-time solvable?</li>
</ol>

<hr />

<p>This reduction demonstrates how making one part of a combined problem trivial (by setting k’ = 1) can reduce a complex problem to a simpler one, enabling reductions between graph problems.</p>]]></content><author><name></name></author><category term="Algorithms" /><category term="Complexity Theory" /><category term="NP-Hard" /><summary type="html"><![CDATA[A detailed proof showing how to reduce Independent Set to the problem of finding both a clique and an independent set of given sizes.]]></summary></entry><entry><title type="html">Reduction: Independent Set to Sparse Subgraph</title><link href="https://robinali34.github.io/blog_algorithms//blog_algorithms/2025/11/22/reduction-independent-set-to-sparse-subgraph/" rel="alternate" type="text/html" title="Reduction: Independent Set to Sparse Subgraph" /><published>2025-11-22T00:00:00+00:00</published><updated>2025-11-22T00:00:00+00:00</updated><id>https://robinali34.github.io/blog_algorithms//blog_algorithms/2025/11/22/reduction-independent-set-to-sparse-subgraph</id><content type="html" xml:base="https://robinali34.github.io/blog_algorithms//blog_algorithms/2025/11/22/reduction-independent-set-to-sparse-subgraph/"><![CDATA[<h2 id="introduction">Introduction</h2>

<p>This post provides a detailed proof that the Sparse Subgraph problem is NP-complete by reducing from Independent Set. Sparse Subgraph asks for a set of vertices with at most a specified number of edges between them, generalizing the independent set problem.</p>

<h2 id="problem-definitions">Problem Definitions</h2>

<h3 id="sparse-subgraph-problem">Sparse Subgraph Problem</h3>

<p><strong>Input:</strong></p>
<ul>
  <li>An undirected graph G = (V, E)</li>
  <li>Two integers a ≥ 1 and b ≥ 0</li>
</ul>

<p><strong>Output:</strong> YES if there exists a set of a vertices of G such that there are at most b edges between them, NO otherwise.</p>

<p><strong>Note:</strong> The problem asks to find a set S ⊆ V with <code class="language-plaintext highlighter-rouge">|S|</code> = a such that the number of edges in the subgraph induced by S is at most b.</p>

<h3 id="independent-set-problem">Independent Set Problem</h3>

<p><strong>Input:</strong></p>
<ul>
  <li>An undirected graph G = (V, E)</li>
  <li>Integer k ≥ 1</li>
</ul>

<p><strong>Output:</strong> YES if G contains an independent set of size k (set of k vertices with no edges between them), NO otherwise.</p>

<h2 id="1-np-completeness-proof-of-sparse-subgraph-solution-validation">1. NP-Completeness Proof of Sparse Subgraph: Solution Validation</h2>

<h3 id="sparse-subgraph--np">Sparse Subgraph ∈ NP</h3>

<p><strong>Verification Algorithm:</strong>
Given a candidate solution (set S of a vertices):</p>
<ol>
  <li>Check that <code class="language-plaintext highlighter-rouge">|S|</code> = a: O(1) time</li>
  <li>Count the number of edges in the subgraph induced by S: O(a²) time</li>
  <li>Check if the count ≤ b: O(1) time</li>
</ol>

<p><strong>Total Time:</strong> O(a²), which is polynomial in input size.</p>

<p><strong>Conclusion:</strong> Sparse Subgraph ∈ NP.</p>

<h2 id="2-reduce-independent-set-to-sparse-subgraph">2. Reduce Independent Set to Sparse Subgraph</h2>

<p><strong>Key Insight:</strong> Given an Independent Set instance, we can reduce it to Sparse Subgraph by setting a = k and b = 0. An independent set of size k has exactly 0 edges (no pairs are adjacent). Therefore, finding a k-independent set is equivalent to finding a set of k vertices with at most 0 edges.</p>

<p><strong>Hint:</strong> An independent set has no edges between its vertices. Therefore, a set of k vertices is an independent set if and only if it has 0 edges. Setting b = 0 ensures we find an independent set.</p>

<h3 id="21-input-conversion">2.1 Input Conversion</h3>

<p>Given an Independent Set instance (G, k) where G = (V, E) with n vertices, we construct a Sparse Subgraph instance (G’, a, b).</p>

<p><strong>Construction:</strong></p>

<p><strong>Step 1: Copy Graph</strong></p>
<ul>
  <li>G’ = G (same graph, no changes)</li>
</ul>

<p><strong>Step 2: Set Parameters</strong></p>
<ul>
  <li>a = k (we want a set of k vertices)</li>
  <li>b = 0 (an independent set has no edges)</li>
</ul>

<p><strong>Step 3: Result</strong></p>
<ul>
  <li>Sparse Subgraph instance: (G’, k, 0)</li>
</ul>

<p><strong>Detailed Example:</strong></p>

<p>Consider Independent Set instance:</p>
<ul>
  <li>Graph G with vertices {1, 2, 3, 4}</li>
  <li>Edges: {(1,2), (2,3), (3,4), (4,1)}</li>
  <li>k = 2 (want independent set of size 2)</li>
</ul>

<p><strong>Transformation:</strong></p>
<ul>
  <li>G’ = G (same graph)</li>
  <li>a = 2</li>
  <li>b = 0</li>
</ul>

<p><strong>Sparse Subgraph instance:</strong> (G’, 2, 0)</p>

<p><strong>Note:</strong> A set of 2 vertices with at most 0 edges must have exactly 0 edges, which means the two vertices are not adjacent (an independent set of size 2).</p>

<h3 id="22-output-conversion">2.2 Output Conversion</h3>

<p><strong>Given:</strong> Sparse Subgraph solution (set S of a = k vertices with at most b = 0 edges)</p>

<p><strong>Extract Independent Set:</strong></p>
<ul>
  <li>Use S as the independent set</li>
  <li>S has k vertices</li>
  <li>S has at most 0 edges</li>
  <li>Since the number of edges is non-negative, S has exactly 0 edges</li>
  <li>Therefore, no pairs of vertices in S are adjacent</li>
  <li>S is an independent set of size k</li>
</ul>

<p><strong>Verify Satisfaction:</strong></p>
<ul>
  <li>S has k vertices: ✓</li>
  <li>No pairs of vertices in S are adjacent: ✓ (since there are 0 edges)</li>
  <li>Therefore, S is an independent set of size k</li>
</ul>

<h2 id="3-correctness-justification">3. Correctness Justification</h2>

<h3 id="31-if-independent-set-has-a-solution-then-sparse-subgraph-has-a-solution">3.1 If Independent Set has a solution, then Sparse Subgraph has a solution</h3>

<p><strong>Given:</strong> Independent Set instance (G, k) has solution I (independent set of size k).</p>

<p><strong>Construct Sparse Subgraph Solution:</strong></p>
<ul>
  <li>Use I as the set S</li>
  <li>S = I has k = a vertices</li>
  <li>Since I is an independent set, no pairs of vertices in I are adjacent</li>
  <li>Therefore, I has exactly 0 edges</li>
  <li>Number of edges = 0 ≤ b = 0 ✓</li>
</ul>

<p><strong>Verify Satisfaction:</strong></p>
<ul>
  <li>S has a = k vertices: ✓ (since I has k vertices)</li>
  <li>S has at most b = 0 edges: ✓ (since I is an independent set)</li>
  <li>Therefore, S is a solution to Sparse Subgraph</li>
</ul>

<p><strong>Conclusion:</strong> Sparse Subgraph has a solution.</p>

<h3 id="32a-if-independent-set-does-not-have-a-solution-then-sparse-subgraph-has-no-solution">3.2a If Independent Set does not have a solution, then Sparse Subgraph has no solution</h3>

<p><strong>Given:</strong> Independent Set instance (G, k) has no solution (no independent set of size k).</p>

<p><strong>Proof:</strong></p>

<p><strong>Assume:</strong> Sparse Subgraph instance (G’, k, 0) has a solution (set S of k vertices with at most 0 edges).</p>

<p><strong>Extract Independent Set:</strong></p>
<ul>
  <li>Use S as the candidate independent set</li>
  <li>S has k vertices</li>
  <li>S has at most 0 edges</li>
  <li>Since the number of edges is non-negative, S has exactly 0 edges</li>
  <li>Therefore, no pairs of vertices in S are adjacent</li>
  <li>S is an independent set of size k in G’ = G</li>
</ul>

<p><strong>Contradiction:</strong></p>
<ul>
  <li>S is an independent set of size k in G</li>
  <li>This contradicts the assumption that G has no independent set of size k</li>
</ul>

<p><strong>Conclusion:</strong> Sparse Subgraph has no solution.</p>

<h3 id="32b-if-sparse-subgraph-has-a-solution-then-independent-set-has-a-solution">3.2b If Sparse Subgraph has a solution, then Independent Set has a solution</h3>

<p><strong>Given:</strong> Sparse Subgraph instance (G’, k, 0) has solution (set S of k vertices with at most 0 edges).</p>

<p><strong>Extract Independent Set:</strong></p>
<ul>
  <li>Use S as the independent set</li>
  <li>S has k vertices</li>
  <li>S has at most 0 edges</li>
  <li>Since the number of edges is non-negative, S has exactly 0 edges</li>
  <li>Therefore, no pairs of vertices in S are adjacent</li>
</ul>

<p><strong>Verify Satisfaction:</strong></p>

<p><strong>Independent Set Requirements:</strong></p>
<ul>
  <li>S has exactly k vertices: ✓ (by assumption)</li>
  <li>No pairs of vertices in S are adjacent: ✓ (since there are 0 edges)</li>
  <li>Therefore, S is an independent set of size k in G’ = G</li>
</ul>

<p><strong>Key Insight:</strong></p>
<ul>
  <li>A set of k vertices can have at least 0 edges (when it forms an independent set)</li>
  <li>Requiring at most 0 edges forces the set to have exactly 0 edges</li>
  <li>This means no pairs are adjacent, which is exactly the definition of an independent set</li>
  <li>Therefore, any solution to Sparse Subgraph gives us an independent set</li>
</ul>

<p><strong>Conclusion:</strong> The set S forms an independent set of size k in G, so Independent Set has a solution.</p>

<h2 id="polynomial-time-analysis">Polynomial Time Analysis</h2>

<p><strong>Input Size:</strong></p>
<ul>
  <li>Independent Set: Graph G with n vertices and m edges, integer k</li>
  <li>Sparse Subgraph: Graph G’ with n vertices and m edges, integers a = k and b = 0</li>
</ul>

<p><strong>Construction Time:</strong></p>
<ul>
  <li>Copy graph G: O(n + m) time</li>
  <li>Set a = k: O(1) time</li>
  <li>Set b = 0: O(1) time</li>
  <li>Total: O(n + m) time</li>
</ul>

<p><strong>Conclusion:</strong> Reduction is polynomial-time.</p>

<h2 id="summary">Summary</h2>

<p>We have shown:</p>
<ol>
  <li><strong>Sparse Subgraph ∈ NP</strong>: Solutions can be verified in polynomial time</li>
  <li><strong>Independent Set ≤ₚ Sparse Subgraph</strong>: Polynomial-time reduction exists</li>
  <li><strong>Correctness</strong>: Independent Set has solution ↔ Sparse Subgraph has solution</li>
</ol>

<p><strong>Therefore, Sparse Subgraph is NP-complete.</strong></p>

<h2 id="key-insights">Key Insights</h2>

<ol>
  <li><strong>Edge Count Equivalence</strong>: An independent set of size k has exactly 0 edges (the minimum possible)</li>
  <li><strong>Minimum Constraint</strong>: Requiring at most 0 edges forces exactly 0 edges (since that’s the minimum)</li>
  <li><strong>Independent Set Characterization</strong>: A set of k vertices is an independent set if and only if it has 0 edges</li>
  <li><strong>Preservation</strong>: The reduction preserves the independent set structure through edge count requirements</li>
</ol>

<h2 id="practice-questions">Practice Questions</h2>

<ol>
  <li><strong>Modify the reduction</strong> to reduce k-Independent Set to Sparse Subgraph for fixed k. Does the complexity change?</li>
  <li><strong>Extend the reduction</strong> to handle weighted graphs. How would you set the parameters?</li>
  <li><strong>Consider the optimization version:</strong> How would you reduce the optimization version of Independent Set to Sparse Subgraph?</li>
  <li><strong>Prove the reverse reduction:</strong> Can we reduce Sparse Subgraph to Independent Set? How?</li>
  <li><strong>Investigate special cases:</strong> For what values of a and b is Sparse Subgraph polynomial-time solvable?</li>
</ol>

<hr />

<p>This reduction demonstrates how edge sparsity constraints can encode independent set requirements, enabling reductions between graph structure problems.</p>]]></content><author><name></name></author><category term="Algorithms" /><category term="Complexity Theory" /><category term="NP-Hard" /><summary type="html"><![CDATA[A detailed proof showing how to reduce Independent Set to Sparse Subgraph, demonstrating that Sparse Subgraph is NP-complete.]]></summary></entry><entry><title type="html">Reduction: Rudrata Cycle to Reliable Network</title><link href="https://robinali34.github.io/blog_algorithms//blog_algorithms/2025/11/22/reduction-rudrata-cycle-to-reliable-network/" rel="alternate" type="text/html" title="Reduction: Rudrata Cycle to Reliable Network" /><published>2025-11-22T00:00:00+00:00</published><updated>2025-11-22T00:00:00+00:00</updated><id>https://robinali34.github.io/blog_algorithms//blog_algorithms/2025/11/22/reduction-rudrata-cycle-to-reliable-network</id><content type="html" xml:base="https://robinali34.github.io/blog_algorithms//blog_algorithms/2025/11/22/reduction-rudrata-cycle-to-reliable-network/"><![CDATA[<h2 id="introduction">Introduction</h2>

<p>This post provides a detailed proof that the Reliable Network problem is NP-complete by reducing from Rudrata Cycle. Reliable Network asks for a graph that satisfies connectivity requirements within a budget, generalizing the Hamiltonian cycle problem.</p>

<h2 id="problem-definitions">Problem Definitions</h2>

<h3 id="reliable-network-problem">Reliable Network Problem</h3>

<p><strong>Input:</strong></p>
<ul>
  <li>Two n × n matrices:
    <ul>
      <li>Distance matrix d_ij (cost of edge between vertices i and j)</li>
      <li>Connectivity requirement matrix r_ij (required number of vertex-disjoint paths between i and j)</li>
    </ul>
  </li>
  <li>A budget b ≥ 0</li>
</ul>

<p><strong>Output:</strong> YES if there exists a graph G = ({1, 2, …, n}, E) such that:</p>
<ol>
  <li>The total cost of all edges is b or less: ∑_{(i,j) ∈ E} d_ij ≤ b</li>
  <li>Between any two distinct vertices i and j, there are r_ij vertex-disjoint paths</li>
</ol>

<p>NO otherwise.</p>

<p><strong>Note:</strong> Vertex-disjoint paths are paths that share no vertices except possibly their endpoints.</p>

<h3 id="rudrata-cycle-problem">Rudrata Cycle Problem</h3>

<p><strong>Input:</strong></p>
<ul>
  <li>An undirected graph G = (V, E)</li>
</ul>

<p><strong>Output:</strong> YES if G contains a Rudrata cycle (Hamiltonian cycle visiting all vertices exactly once), NO otherwise.</p>

<h2 id="1-np-completeness-proof-of-reliable-network-solution-validation">1. NP-Completeness Proof of Reliable Network: Solution Validation</h2>

<h3 id="reliable-network--np">Reliable Network ∈ NP</h3>

<p><strong>Verification Algorithm:</strong>
Given a candidate solution (graph G = ({1, 2, …, n}, E)):</p>
<ol>
  <li>Check that total cost ≤ b: O(<code class="language-plaintext highlighter-rouge">|E|</code>) time</li>
  <li>For each pair (i, j) with i ≠ j:
    <ul>
      <li>Find r_ij vertex-disjoint paths: O(n²) time using max-flow algorithms</li>
      <li>Check that at least r_ij paths exist: O(n²) time</li>
    </ul>
  </li>
  <li>Check all pairs: O(n⁴) time</li>
</ol>

<p><strong>Total Time:</strong> O(n⁴), which is polynomial in input size.</p>

<p><strong>Conclusion:</strong> Reliable Network ∈ NP.</p>

<h2 id="2-reduce-rudrata-cycle-to-reliable-network">2. Reduce Rudrata Cycle to Reliable Network</h2>

<p><strong>Key Insight:</strong> Given a Rudrata Cycle instance, we can reduce it to Reliable Network by setting all distances to 1 or 2, all connectivity requirements to 2, and budget to n. A graph with n vertices, n edges, cost ≤ n, and 2 vertex-disjoint paths between all pairs must be a cycle, which is exactly a Rudrata cycle.</p>

<p><strong>Hint:</strong> If all d_ij’s are 1 or 2, b = n, and all r_ij’s are 2, then we need a graph with exactly n edges (each of cost 1) that is 2-connected. A cycle on n vertices has exactly n edges and provides 2 vertex-disjoint paths between any two vertices (going clockwise and counterclockwise).</p>

<h3 id="21-input-conversion">2.1 Input Conversion</h3>

<p>Given a Rudrata Cycle instance G = (V, E) with n vertices, we construct a Reliable Network instance (d, r, b).</p>

<p><strong>Construction:</strong></p>

<p><strong>Step 1: Set Distance Matrix</strong></p>
<ul>
  <li>For each pair (i, j) with i ≠ j:
    <ul>
      <li>If (i, j) ∈ E: d_ij = 1 (edge exists in original graph)</li>
      <li>If (i, j) ∉ E: d_ij = 2 (edge doesn’t exist, higher cost)</li>
    </ul>
  </li>
  <li>d_ii = 0 (no self-loops)</li>
</ul>

<p><strong>Step 2: Set Connectivity Requirements</strong></p>
<ul>
  <li>For all pairs (i, j) with i ≠ j: r_ij = 2</li>
  <li>r_ii = 0 (no requirement for same vertex)</li>
</ul>

<p><strong>Step 3: Set Budget</strong></p>
<ul>
  <li>b = n (we can afford exactly n edges of cost 1)</li>
</ul>

<p><strong>Step 4: Result</strong></p>
<ul>
  <li>Reliable Network instance: (d, r, n) where:
    <ul>
      <li>d_ij ∈ {1, 2} for all i ≠ j</li>
      <li>r_ij = 2 for all i ≠ j</li>
      <li>b = n</li>
    </ul>
  </li>
</ul>

<p><strong>Detailed Example:</strong></p>

<p>Consider Rudrata Cycle instance:</p>
<ul>
  <li>Graph G with vertices {1, 2, 3, 4}</li>
  <li>Edges: {(1,2), (2,3), (3,4), (4,1)}</li>
</ul>

<p><strong>Transformation:</strong></p>
<ul>
  <li>Distance matrix d:
    <ul>
      <li>d₁₂ = d₂₃ = d₃₄ = d₄₁ = 1 (edges exist)</li>
      <li>All other d_ij = 2 (edges don’t exist)</li>
    </ul>
  </li>
  <li>Connectivity matrix r:
    <ul>
      <li>r_ij = 2 for all i ≠ j</li>
    </ul>
  </li>
  <li>Budget: b = 4</li>
</ul>

<p><strong>Reliable Network instance:</strong> (d, r, 4)</p>

<p><strong>Note:</strong> A cycle on 4 vertices has 4 edges (cost 4) and provides 2 vertex-disjoint paths between any pair.</p>

<h3 id="22-output-conversion">2.2 Output Conversion</h3>

<p><strong>Given:</strong> Reliable Network solution (graph G’ = ({1, 2, …, n}, E’) with cost ≤ n and r_ij = 2 vertex-disjoint paths between all pairs)</p>

<p><strong>Extract Rudrata Cycle:</strong></p>
<ul>
  <li>Since b = n and all edges cost at least 1, G’ has exactly n edges, all of cost 1</li>
  <li>Since r_ij = 2 for all pairs, G’ is 2-connected</li>
  <li>A 2-connected graph with n vertices and n edges must be a cycle</li>
  <li>Therefore, G’ is a cycle visiting all n vertices exactly once (a Rudrata cycle)</li>
</ul>

<p><strong>Verify Satisfaction:</strong></p>
<ul>
  <li>G’ visits all n vertices: ✓ (by construction)</li>
  <li>G’ forms a cycle: ✓ (2-connected with n vertices and n edges)</li>
  <li>All edges in G’ exist in original graph G: ✓ (since d_ij = 1 only for edges in G)</li>
  <li>Therefore, G’ is a Rudrata cycle in G</li>
</ul>

<h2 id="3-correctness-justification">3. Correctness Justification</h2>

<h3 id="31-if-rudrata-cycle-has-a-solution-then-reliable-network-has-a-solution">3.1 If Rudrata Cycle has a solution, then Reliable Network has a solution</h3>

<p><strong>Given:</strong> Rudrata Cycle instance G has solution C (Hamiltonian cycle).</p>

<p><strong>Construct Reliable Network Solution:</strong></p>
<ul>
  <li>Use cycle C as the graph G’</li>
  <li>G’ has exactly n edges (one per vertex in the cycle)</li>
  <li>All edges in C have cost 1 (since they exist in G, so d_ij = 1)</li>
  <li>Total cost = n ≤ b = n ✓</li>
</ul>

<p><strong>Verify Connectivity:</strong></p>
<ul>
  <li>For any two vertices i and j in the cycle:
    <ul>
      <li>Path 1: Follow the cycle in one direction from i to j</li>
      <li>Path 2: Follow the cycle in the other direction from i to j</li>
      <li>These two paths are vertex-disjoint (except at endpoints)</li>
      <li>Therefore, there are 2 vertex-disjoint paths between i and j ✓</li>
    </ul>
  </li>
  <li>All connectivity requirements r_ij = 2 are satisfied</li>
</ul>

<p><strong>Conclusion:</strong> Reliable Network has a solution.</p>

<h3 id="32a-if-rudrata-cycle-does-not-have-a-solution-then-reliable-network-has-no-solution">3.2a If Rudrata Cycle does not have a solution, then Reliable Network has no solution</h3>

<p><strong>Given:</strong> Rudrata Cycle instance G has no solution (no Hamiltonian cycle).</p>

<p><strong>Proof:</strong></p>

<p><strong>Assume:</strong> Reliable Network instance (d, r, n) has a solution (graph G’ with cost ≤ n and 2 vertex-disjoint paths between all pairs).</p>

<p><strong>Extract Cycle:</strong></p>
<ul>
  <li>Since b = n and all edges cost at least 1, G’ has at most n edges</li>
  <li>Since r_ij = 2 for all pairs, G’ is 2-connected</li>
  <li>A 2-connected graph with n vertices needs at least n edges (by connectivity requirements)</li>
  <li>Therefore, G’ has exactly n edges, all of cost 1</li>
  <li>A 2-connected graph with n vertices and exactly n edges must be a cycle</li>
  <li>Therefore, G’ is a cycle on n vertices</li>
  <li>Since all edges have cost 1, all edges in G’ exist in the original graph G</li>
  <li>Therefore, G’ is a Rudrata cycle in G</li>
</ul>

<p><strong>Contradiction:</strong></p>
<ul>
  <li>G’ is a Rudrata cycle in G</li>
  <li>This contradicts the assumption that G has no Rudrata cycle</li>
</ul>

<p><strong>Conclusion:</strong> Reliable Network has no solution.</p>

<h3 id="32b-if-reliable-network-has-a-solution-then-rudrata-cycle-has-a-solution">3.2b If Reliable Network has a solution, then Rudrata Cycle has a solution</h3>

<p><strong>Given:</strong> Reliable Network instance (d, r, n) has solution (graph G’ with cost ≤ n and 2 vertex-disjoint paths between all pairs).</p>

<p><strong>Extract Cycle:</strong></p>
<ul>
  <li>Since b = n and all edges cost at least 1, G’ has at most n edges</li>
  <li>Since r_ij = 2 for all pairs, G’ is 2-connected</li>
  <li>A 2-connected graph with n vertices needs at least n edges</li>
  <li>Therefore, G’ has exactly n edges, all of cost 1</li>
  <li>A 2-connected graph with n vertices and exactly n edges must be a cycle</li>
  <li>Since all edges have cost 1, they correspond to edges in the original graph G (where d_ij = 1)</li>
  <li>Therefore, G’ is a cycle in G visiting all n vertices</li>
</ul>

<p><strong>Verify Satisfaction:</strong></p>

<p><strong>Rudrata Cycle Requirements:</strong></p>
<ul>
  <li>G’ visits all n vertices: ✓ (by construction, G’ = ({1, 2, …, n}, E’))</li>
  <li>G’ forms a cycle: ✓ (2-connected with n vertices and n edges)</li>
  <li>All edges in G’ exist in G: ✓ (since d_ij = 1 only for edges in G)</li>
  <li>Therefore, G’ is a Rudrata cycle in G</li>
</ul>

<p><strong>Key Insight:</strong></p>
<ul>
  <li>With budget b = n and all edges costing at least 1, we can afford exactly n edges</li>
  <li>Requiring r_ij = 2 vertex-disjoint paths between all pairs forces the graph to be 2-connected</li>
  <li>A 2-connected graph with n vertices and n edges must be a cycle</li>
  <li>A cycle provides exactly 2 vertex-disjoint paths between any two vertices (clockwise and counterclockwise)</li>
  <li>Therefore, any solution to Reliable Network gives us a Rudrata cycle</li>
</ul>

<p><strong>Conclusion:</strong> The graph G’ forms a Rudrata cycle in G, so Rudrata Cycle has a solution.</p>

<h2 id="polynomial-time-analysis">Polynomial Time Analysis</h2>

<p><strong>Input Size:</strong></p>
<ul>
  <li>Rudrata Cycle: Graph G with n vertices and m edges</li>
  <li>Reliable Network: Two n × n matrices (n² entries each), integer b = n</li>
</ul>

<p><strong>Construction Time:</strong></p>
<ul>
  <li>Create distance matrix: O(n²) time (check each pair)</li>
  <li>Create connectivity matrix: O(n²) time (set all r_ij = 2)</li>
  <li>Set b = n: O(1) time</li>
  <li>Total: O(n²) time</li>
</ul>

<p><strong>Conclusion:</strong> Reduction is polynomial-time.</p>

<h2 id="summary">Summary</h2>

<p>We have shown:</p>
<ol>
  <li><strong>Reliable Network ∈ NP</strong>: Solutions can be verified in polynomial time</li>
  <li><strong>Rudrata Cycle ≤ₚ Reliable Network</strong>: Polynomial-time reduction exists</li>
  <li><strong>Correctness</strong>: Rudrata Cycle has solution ↔ Reliable Network has solution</li>
</ol>

<p><strong>Therefore, Reliable Network is NP-complete.</strong></p>

<h2 id="key-insights">Key Insights</h2>

<ol>
  <li><strong>Budget Constraint</strong>: Setting b = n with all edges costing at least 1 forces exactly n edges</li>
  <li><strong>Connectivity Requirement</strong>: Requiring r_ij = 2 vertex-disjoint paths forces 2-connectivity</li>
  <li><strong>Cycle Characterization</strong>: A 2-connected graph with n vertices and n edges must be a cycle</li>
  <li><strong>Path Structure</strong>: A cycle provides exactly 2 vertex-disjoint paths between any two vertices</li>
  <li><strong>Cost Encoding</strong>: Using d_ij = 1 for existing edges and d_ij = 2 for non-existing edges ensures only original edges are used</li>
</ol>

<h2 id="practice-questions">Practice Questions</h2>

<ol>
  <li><strong>Modify the reduction</strong> to handle different connectivity requirements. What if r_ij varies?</li>
  <li><strong>Extend the reduction</strong> to handle weighted graphs. How would you set the distance matrix?</li>
  <li><strong>Consider the optimization version:</strong> How would you reduce the optimization version of Rudrata Cycle to Reliable Network?</li>
  <li><strong>Prove the reverse reduction:</strong> Can we reduce Reliable Network to Rudrata Cycle? How?</li>
  <li><strong>Investigate special cases:</strong> For what values of r_ij and b is Reliable Network polynomial-time solvable?</li>
</ol>

<hr />

<p>This reduction demonstrates how connectivity and budget constraints can encode Hamiltonian cycle requirements, enabling reductions between network design and cycle-finding problems.</p>]]></content><author><name></name></author><category term="Algorithms" /><category term="Complexity Theory" /><category term="NP-Hard" /><summary type="html"><![CDATA[A detailed proof showing how to reduce Rudrata Cycle to Reliable Network, demonstrating that Reliable Network is NP-complete.]]></summary></entry><entry><title type="html">Reduction: Rudrata Cycle to Traveling Salesman Problem</title><link href="https://robinali34.github.io/blog_algorithms//blog_algorithms/2025/11/22/reduction-rudrata-cycle-to-tsp/" rel="alternate" type="text/html" title="Reduction: Rudrata Cycle to Traveling Salesman Problem" /><published>2025-11-22T00:00:00+00:00</published><updated>2025-11-22T00:00:00+00:00</updated><id>https://robinali34.github.io/blog_algorithms//blog_algorithms/2025/11/22/reduction-rudrata-cycle-to-tsp</id><content type="html" xml:base="https://robinali34.github.io/blog_algorithms//blog_algorithms/2025/11/22/reduction-rudrata-cycle-to-tsp/"><![CDATA[<h2 id="introduction">Introduction</h2>

<p>This post provides a detailed proof that the Traveling Salesman Problem (TSP) is NP-complete by reducing from Rudrata Cycle. The reduction transforms the problem of finding a Hamiltonian cycle into finding a minimum-cost tour visiting all cities.</p>

<h2 id="problem-definitions">Problem Definitions</h2>

<h3 id="traveling-salesman-problem-tsp">Traveling Salesman Problem (TSP)</h3>

<p><strong>Input:</strong></p>
<ul>
  <li>A complete undirected graph G = (V, E) with n vertices (cities)</li>
  <li>Edge weights w: E → ℤ⁺ (distances/costs)</li>
  <li>Integer B ≥ 0 (budget)</li>
</ul>

<p><strong>Output:</strong> YES if there exists a tour (cycle visiting all vertices) with total cost ≤ B, NO otherwise.</p>

<h3 id="rudrata-cycle-problem">Rudrata Cycle Problem</h3>

<p><strong>Input:</strong></p>
<ul>
  <li>An undirected graph G = (V, E)</li>
</ul>

<p><strong>Output:</strong> YES if G contains a Rudrata cycle (Hamiltonian cycle visiting all vertices exactly once), NO otherwise.</p>

<h2 id="1-np-completeness-proof-of-tsp-solution-validation">1. NP-Completeness Proof of TSP: Solution Validation</h2>

<h3 id="tsp--np">TSP ∈ NP</h3>

<p><strong>Verification Algorithm:</strong>
Given a candidate solution (tour π = v₁, v₂, …, vₙ, v₁):</p>
<ol>
  <li>Check that π visits all n vertices exactly once: O(n) time</li>
  <li>Check that π forms a cycle: O(1) time (v₁ = vₙ₊₁)</li>
  <li>Compute total cost: ∑ᵢ₌₁ⁿ w(vᵢ, vᵢ₊₁): O(n) time</li>
  <li>Check if total cost ≤ B: O(1) time</li>
</ol>

<p><strong>Total Time:</strong> O(n), which is polynomial in input size.</p>

<p><strong>Conclusion:</strong> TSP ∈ NP.</p>

<h2 id="2-reduce-rudrata-cycle-to-tsp">2. Reduce Rudrata Cycle to TSP</h2>

<p><strong>Key Insight:</strong> Given a Rudrata Cycle instance, we can reduce it to TSP by making the graph complete, setting edge weights to 1 for existing edges and 2 for missing edges, and setting B = n. Then G has a Rudrata cycle if and only if the TSP instance has a tour of cost n.</p>

<p><strong>Hint:</strong> A Rudrata cycle uses exactly n edges, all of which must exist in the original graph. By setting existing edges to weight 1 and missing edges to weight 2, and B = n, we ensure that only tours using existing edges are feasible.</p>

<h3 id="21-input-conversion">2.1 Input Conversion</h3>

<p>Given a Rudrata Cycle instance G = (V, E) with n vertices, we construct a TSP instance (G’, w, B).</p>

<p><strong>Construction:</strong></p>

<p><strong>Step 1: Create Complete Graph</strong></p>
<ul>
  <li>G’ = (V, E’) where E’ contains all pairs of vertices (complete graph)</li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>E’</td>
          <td>= n(n-1)/2</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<p><strong>Step 2: Set Edge Weights</strong></p>
<ul>
  <li>For each edge (u, v) ∈ E (existing edge): w(u, v) = 1</li>
  <li>For each edge (u, v) ∉ E (missing edge): w(u, v) = 2</li>
</ul>

<p><strong>Step 3: Set Budget</strong></p>
<ul>
  <li>B = n (we want a tour using exactly n edges, all of weight 1)</li>
</ul>

<p><strong>Step 4: Result</strong></p>
<ul>
  <li>TSP instance: (G’, w, n)</li>
</ul>

<p><strong>Detailed Example:</strong></p>

<p>Consider Rudrata Cycle instance:</p>
<ul>
  <li>Graph G with vertices {1, 2, 3, 4}</li>
  <li>Edges: {(1,2), (2,3), (3,4), (4,1), (1,3)}</li>
</ul>

<p><strong>Transformation:</strong></p>
<ul>
  <li>G’ = complete graph on {1, 2, 3, 4}</li>
  <li>Edge weights:
    <ul>
      <li>w(1,2) = 1, w(2,3) = 1, w(3,4) = 1, w(4,1) = 1, w(1,3) = 1</li>
      <li>w(2,4) = 2 (missing edge)</li>
    </ul>
  </li>
  <li>B = 4</li>
</ul>

<p><strong>TSP instance:</strong> (G’, w, 4)</p>

<h3 id="22-output-conversion">2.2 Output Conversion</h3>

<p><strong>Given:</strong> TSP solution (tour π with cost ≤ B = n)</p>

<p><strong>Extract Rudrata Cycle:</strong></p>
<ul>
  <li>The tour π visits all n vertices exactly once</li>
  <li>Since cost ≤ n and each edge has weight ≥ 1, the tour uses exactly n edges</li>
  <li>Since B = n and missing edges have weight 2, all edges in the tour must have weight 1</li>
  <li>Therefore, all edges in the tour exist in the original graph G</li>
  <li>π forms a Rudrata cycle in G</li>
</ul>

<p><strong>Verify Satisfaction:</strong></p>
<ul>
  <li>π visits all n vertices exactly once: ✓</li>
  <li>π forms a cycle: ✓</li>
  <li>All edges in π exist in G: ✓ (since they have weight 1)</li>
  <li>Therefore, π is a Rudrata cycle in G</li>
</ul>

<h2 id="3-correctness-justification">3. Correctness Justification</h2>

<h3 id="31-if-rudrata-cycle-has-a-solution-then-tsp-has-a-solution">3.1 If Rudrata Cycle has a solution, then TSP has a solution</h3>

<p><strong>Given:</strong> Rudrata Cycle instance G has solution C (Hamiltonian cycle).</p>

<p><strong>Construct TSP Solution:</strong></p>
<ul>
  <li>Use cycle C as the tour</li>
  <li>C visits all n vertices exactly once</li>
  <li>C uses exactly n edges, all of which exist in G</li>
  <li>Therefore, all edges in C have weight 1</li>
  <li>Total cost = n ≤ B = n</li>
</ul>

<p><strong>Verify Satisfaction:</strong></p>
<ul>
  <li>Tour visits all vertices: ✓ (by definition of Rudrata cycle)</li>
  <li>Tour forms a cycle: ✓ (by definition)</li>
  <li>All edges have weight 1: ✓ (since they exist in G)</li>
  <li>Total cost = n ≤ B: ✓</li>
</ul>

<p><strong>Conclusion:</strong> TSP has a solution.</p>

<h3 id="32a-if-rudrata-cycle-does-not-have-a-solution-then-tsp-has-no-solution">3.2a If Rudrata Cycle does not have a solution, then TSP has no solution</h3>

<p><strong>Given:</strong> Rudrata Cycle instance G has no solution (no Hamiltonian cycle).</p>

<p><strong>Proof:</strong></p>

<p><strong>Assume:</strong> TSP instance (G’, w, n) has a solution (tour π with cost ≤ n).</p>

<p><strong>Extract Cycle:</strong></p>
<ul>
  <li>π visits all n vertices exactly once</li>
  <li>π forms a cycle</li>
  <li>Since cost ≤ n and each edge has weight ≥ 1, π uses exactly n edges</li>
  <li>Since missing edges have weight 2, all edges in π must have weight 1</li>
  <li>Therefore, all edges in π exist in G</li>
  <li>π is a Rudrata cycle in G</li>
</ul>

<p><strong>Contradiction:</strong></p>
<ul>
  <li>π is a Rudrata cycle in G</li>
  <li>This contradicts the assumption that G has no Rudrata cycle</li>
</ul>

<p><strong>Conclusion:</strong> TSP has no solution.</p>

<h3 id="32b-if-tsp-has-a-solution-then-rudrata-cycle-has-a-solution">3.2b If TSP has a solution, then Rudrata Cycle has a solution</h3>

<p><strong>Given:</strong> TSP instance (G’, w, n) has solution (tour π with cost ≤ n).</p>

<p><strong>Extract Cycle:</strong></p>
<ul>
  <li>π visits all n vertices exactly once</li>
  <li>π forms a cycle</li>
  <li>Since cost ≤ n and each edge has weight ≥ 1, π uses exactly n edges</li>
  <li>Since B = n and missing edges have weight 2, all edges in π must have weight 1</li>
  <li>Therefore, all edges in π exist in the original graph G</li>
</ul>

<p><strong>Verify Satisfaction:</strong></p>

<p><strong>Rudrata Cycle Requirements:</strong></p>
<ul>
  <li>π visits all n vertices exactly once: ✓ (by definition of tour)</li>
  <li>π forms a cycle: ✓ (by definition)</li>
  <li>All edges in π exist in G: ✓ (since they have weight 1)</li>
  <li>Therefore, π is a Rudrata cycle in G</li>
</ul>

<p><strong>Key Insight:</strong></p>
<ul>
  <li>A tour of cost n must use exactly n edges, each of weight 1</li>
  <li>Edges of weight 1 correspond to edges in the original graph</li>
  <li>Therefore, the tour is a Rudrata cycle in the original graph</li>
</ul>

<p><strong>Conclusion:</strong> The tour π forms a Rudrata cycle in G, so Rudrata Cycle has a solution.</p>

<h2 id="polynomial-time-analysis">Polynomial Time Analysis</h2>

<p><strong>Input Size:</strong></p>
<ul>
  <li>Rudrata Cycle: Graph G with n vertices and m edges</li>
  <li>TSP: Complete graph G’ with n vertices and n(n-1)/2 edges, weights w, integer B = n</li>
</ul>

<p><strong>Construction Time:</strong></p>
<ul>
  <li>Create complete graph: O(n²) time</li>
  <li>Set edge weights: O(n²) time (check each pair)</li>
  <li>Set B = n: O(1) time</li>
  <li>Total: O(n²) time</li>
</ul>

<p><strong>Conclusion:</strong> Reduction is polynomial-time.</p>

<h2 id="summary">Summary</h2>

<p>We have shown:</p>
<ol>
  <li><strong>TSP ∈ NP</strong>: Solutions can be verified in polynomial time</li>
  <li><strong>Rudrata Cycle ≤ₚ TSP</strong>: Polynomial-time reduction exists</li>
  <li><strong>Correctness</strong>: Rudrata Cycle has solution ↔ TSP has solution</li>
</ol>

<p><strong>Therefore, TSP is NP-complete.</strong></p>

<h2 id="key-insights">Key Insights</h2>

<ol>
  <li><strong>Complete Graph</strong>: Making the graph complete allows any tour while controlling feasibility through weights</li>
  <li><strong>Weight Encoding</strong>: Weight 1 for existing edges, weight 2 for missing edges ensures only existing edges are used</li>
  <li><strong>Budget Constraint</strong>: Setting B = n forces the tour to use exactly n edges, all of weight 1</li>
  <li><strong>Cycle Preservation</strong>: The reduction preserves the cycle structure through the weight assignment</li>
</ol>

<h2 id="practice-questions">Practice Questions</h2>

<ol>
  <li><strong>Modify the reduction</strong> to reduce Rudrata Path to TSP. How would you handle the start and end vertices?</li>
  <li><strong>Extend the reduction</strong> to handle weighted graphs. How would you set the weights?</li>
  <li><strong>Consider metric TSP:</strong> What if we require the triangle inequality? Does the reduction still work?</li>
  <li><strong>Prove the reverse reduction:</strong> Can we reduce TSP to Rudrata Cycle? How?</li>
  <li><strong>Investigate approximation:</strong> How does this reduction relate to approximation algorithms for TSP?</li>
</ol>

<hr />

<p>This reduction demonstrates how edge weights can encode graph structure, enabling reductions between cycle-finding and optimization problems.</p>]]></content><author><name></name></author><category term="Algorithms" /><category term="Complexity Theory" /><category term="NP-Hard" /><summary type="html"><![CDATA[A detailed proof showing how to reduce Rudrata Cycle to Traveling Salesman Problem, demonstrating that TSP is NP-complete.]]></summary></entry></feed>
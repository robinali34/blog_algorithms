<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Reduction: SAT to Circuit Design | Robina Li</title>
<meta name="generator" content="Jekyll v4.3.4" />
<meta property="og:title" content="Reduction: SAT to Circuit Design" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="A detailed proof showing how to reduce SAT to Circuit Design, proving that the Circuit Design problem is NP-complete." />
<meta property="og:description" content="A detailed proof showing how to reduce SAT to Circuit Design, proving that the Circuit Design problem is NP-complete." />
<link rel="canonical" href="https://robinali34.github.io/blog_algorithms//blog_algorithms/2025/11/22/reduction-sat-to-circuit-design/" />
<meta property="og:url" content="https://robinali34.github.io/blog_algorithms//blog_algorithms/2025/11/22/reduction-sat-to-circuit-design/" />
<meta property="og:site_name" content="Robina Li" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-11-22T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Reduction: SAT to Circuit Design" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-11-22T00:00:00+00:00","datePublished":"2025-11-22T00:00:00+00:00","description":"A detailed proof showing how to reduce SAT to Circuit Design, proving that the Circuit Design problem is NP-complete.","headline":"Reduction: SAT to Circuit Design","mainEntityOfPage":{"@type":"WebPage","@id":"https://robinali34.github.io/blog_algorithms//blog_algorithms/2025/11/22/reduction-sat-to-circuit-design/"},"url":"https://robinali34.github.io/blog_algorithms//blog_algorithms/2025/11/22/reduction-sat-to-circuit-design/"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/blog_algorithms/assets/main.css">
  <link rel="stylesheet" href="/blog_algorithms/assets/css/morandi-theme.css"><link type="application/atom+xml" rel="alternate" href="https://robinali34.github.io/blog_algorithms//blog_algorithms/feed.xml" title="Robina Li" /></head>

<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/blog_algorithms/">Robina Li</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
          <a class="page-link" href="/blog_algorithms/posts/">All Posts</a><a class="page-link" href="/blog_algorithms/about/">About</a></div>
      </nav></div>
</header>

<main class="page-content" aria-label="Content"><div class="post-container">

  <div class="post-wrapper">
    <!-- Left Sidebar - Table of Contents -->
    <aside class="post-sidebar-left">
      <div class="sidebar-section toc-section">
        <h3 class="sidebar-title">Table of Contents</h3>
        <nav class="toc-nav" id="tableOfContents">
          <ul class="toc-list" id="tocList">
            <!-- Generated by JavaScript -->
          </ul>
        </nav>
      </div>
    </aside>

    <!-- Main Content -->
    <main class="post-main">
      <article class="post">
        <header class="post-header-content">
          <h1 class="post-title">Reduction: SAT to Circuit Design</h1>
          <div class="post-meta-info">
            <time class="post-date" datetime="2025-11-22T00:00:00+00:00">
              November 22, 2025
            </time><div class="post-categories"><span class="category-tag">Algorithms</span><span class="category-tag">Complexity Theory</span><span class="category-tag">NP-Hard</span></div></div>
        </header>

        <div class="post-content">
          <h2 id="introduction">Introduction</h2>

<p>This post provides a detailed proof that the Circuit Design problem is NP-complete by reducing from SAT. The reduction demonstrates how Boolean satisfiability constraints can be encoded as circuit design requirements, showing the fundamental connection between logical formulas and circuit structures.</p>

<h2 id="problem-definitions">Problem Definitions</h2>

<h3 id="circuit-design-problem">Circuit Design Problem</h3>

<p><strong>Input:</strong></p>
<ul>
  <li>A Boolean formula φ (or Boolean function specification)</li>
  <li>An integer k (maximum circuit size/complexity)</li>
</ul>

<p><strong>Output:</strong> YES if there exists a Boolean circuit of size at most k that computes φ AND outputs TRUE for at least one input assignment, NO otherwise</p>

<p><strong>Circuit Structure:</strong></p>
<ul>
  <li>A Boolean circuit consists of:
    <ul>
      <li>Input gates (variables x₁, …, x_n)</li>
      <li>Logic gates (AND, OR, NOT)</li>
      <li>One output gate</li>
    </ul>
  </li>
  <li>Circuit size: Total number of gates (excluding input gates)</li>
  <li>The circuit computes a Boolean function f: {0,1}ⁿ → {0,1}</li>
</ul>

<p><strong>Problem Variant:</strong></p>
<ul>
  <li>Given formula φ and size k, does there exist a circuit of size ≤ k that:
    <ol>
      <li>Computes φ (outputs φ(x) for input x)</li>
      <li>Outputs TRUE for at least one input x</li>
    </ol>
  </li>
</ul>

<h3 id="sat-problem">SAT Problem</h3>

<p><strong>Input:</strong> A Boolean formula φ in CNF (Conjunctive Normal Form)</p>

<p><strong>Output:</strong> YES if φ is satisfiable, NO otherwise</p>

<p><strong>SAT:</strong> The problem of determining whether there exists a truth assignment to variables that makes the formula TRUE.</p>

<h2 id="1-np-completeness-proof-of-circuit-design-solution-validation">1. NP-Completeness Proof of Circuit Design: Solution Validation</h2>

<h3 id="circuit-design--np">Circuit Design ∈ NP</h3>

<p><strong>Verification Algorithm:</strong>
Given a candidate solution (circuit C):</p>
<ol>
  <li>Check that circuit C has size ≤ k: O(n) time (since k ≤ n in typical cases)</li>
  <li>Check that C is a valid circuit structure:
    <ul>
      <li>Verify gates are properly connected: O(n) time</li>
      <li>Verify no cycles (circuit is acyclic): O(n) time</li>
    </ul>
  </li>
  <li>Evaluate circuit C on all input combinations to verify it computes the desired function:
    <ul>
      <li>For each of 2ⁿ input combinations: O(n) time to evaluate</li>
      <li>Total: O(2ⁿ · n) time</li>
    </ul>
  </li>
</ol>

<p><strong>Total Time:</strong> O(2ⁿ · k), which is exponential in n but polynomial in the size of the circuit specification (if given as truth table or formula).</p>

<p><strong>Note:</strong> If the function is specified as a Boolean formula φ of size m:</p>
<ul>
  <li>We can verify that C computes φ by checking equivalence: O(m · k) time</li>
  <li>We can check if C outputs TRUE for some input by evaluating on all inputs or using a SAT solver on the circuit</li>
  <li>This verification is polynomial in the size of φ and k</li>
</ul>

<p><strong>Conclusion:</strong> Circuit Design ∈ NP.</p>

<h2 id="2-reduce-sat-to-circuit-design">2. Reduce SAT to Circuit Design</h2>

<p><strong>Key Insight:</strong> A Boolean formula φ is satisfiable if and only if there exists a circuit that computes φ (which always exists - the formula itself is a circuit). The key is to encode the satisfiability question as a circuit design problem with size constraints.</p>

<p><strong>Hint:</strong> Convert the SAT formula into a circuit design problem where we ask: “Does there exist a circuit of a certain size that outputs TRUE for at least one input?” This is equivalent to asking if the formula is satisfiable.</p>

<h3 id="21-input-conversion">2.1 Input Conversion</h3>

<p>Given a SAT instance: Boolean formula φ in CNF with variables x₁, x₂, …, x_n and clauses C₁, C₂, …, C_m.</p>

<p><strong>Construction:</strong></p>

<p><strong>Step 1: Convert Formula to Circuit Specification</strong></p>
<ul>
  <li>The formula φ naturally corresponds to a Boolean circuit:
    <ul>
      <li>Each variable xᵢ is an input</li>
      <li>Each clause Cⱼ = (l₁ ∨ l₂ ∨ … ∨ lₖ) is an OR gate</li>
      <li>The overall formula φ = C₁ ∧ C₂ ∧ … ∧ C_m is an AND of clauses</li>
    </ul>
  </li>
  <li>This gives us a circuit structure that computes φ</li>
</ul>

<p><strong>Step 2: Formulate Circuit Design Problem</strong></p>
<ul>
  <li><strong>Input variables:</strong> x₁, x₂, …, x_n</li>
  <li><strong>Desired function:</strong> The circuit should compute φ</li>
  <li><strong>Size constraint:</strong> Set k = m + n (number of clauses + number of variables)
    <ul>
      <li>This allows the natural circuit representation:
        <ul>
          <li>n input gates (variables)</li>
          <li>m OR gates (one per clause)</li>
          <li>1 AND gate (combining clauses)</li>
          <li>Total: n + m + 1 gates</li>
        </ul>
      </li>
      <li>Actually, we need to be more careful about gate counting</li>
    </ul>
  </li>
</ul>

<p><strong>Refined Construction:</strong></p>

<p><strong>Circuit Structure:</strong></p>
<ul>
  <li>For each variable xᵢ: input gate</li>
  <li>For each clause Cⱼ = (l₁ ∨ l₂ ∨ … ∨ lₖ):
    <ul>
      <li>Create OR gate computing l₁ ∨ l₂ ∨ … ∨ lₖ</li>
      <li>This requires k-1 OR gates for a clause with k literals</li>
    </ul>
  </li>
  <li>Create AND gate combining all clause outputs</li>
  <li>Total gates: n (inputs) + ∑ⱼ (<code class="language-plaintext highlighter-rouge">|Cⱼ|</code> - 1) (OR gates) + 1 (final AND) = n + m’ + 1 where m’ is total literals</li>
</ul>

<p><strong>Simplified Approach:</strong></p>
<ul>
  <li>Set k = n + m + 1 (sufficient for the natural circuit)</li>
  <li>Or set k large enough to allow the formula’s circuit representation</li>
</ul>

<p><strong>Key Property:</strong></p>
<ul>
  <li>φ is satisfiable ↔ There exists a circuit of size ≤ k computing φ that outputs TRUE for at least one input</li>
  <li>The natural circuit for φ has size ≤ k (by construction)</li>
  <li>If φ is satisfiable, this circuit outputs TRUE for satisfying assignments</li>
  <li>If φ is unsatisfiable, any circuit computing φ outputs FALSE for all inputs</li>
</ul>

<p><strong>Final Construction:</strong></p>
<ul>
  <li><strong>Input variables:</strong> x₁, x₂, …, x_n (same as SAT instance)</li>
  <li><strong>Desired function:</strong> Circuit should compute φ(x₁, …, x_n)</li>
  <li><strong>Size bound:</strong> k = n + m + L + 1 where:
    <ul>
      <li>n = number of variables</li>
      <li>m = number of clauses</li>
      <li>L = total number of literals across all clauses</li>
      <li>+1 for final AND gate</li>
    </ul>
  </li>
  <li>Return Circuit Design instance: inputs x₁, …, x_n, function φ, size bound k</li>
</ul>

<h3 id="22-output-conversion">2.2 Output Conversion</h3>

<p><strong>Given:</strong> Circuit Design solution (circuit C of size ≤ k computing φ)</p>

<p><strong>Extract SAT Solution:</strong></p>
<ul>
  <li>Evaluate circuit C to find an input assignment that makes output TRUE</li>
  <li>Since C computes φ, if C outputs TRUE for some input, then φ is satisfiable</li>
  <li>Return the input assignment (x₁, …, x_n) that makes C output TRUE</li>
</ul>

<p><strong>Verify SAT:</strong></p>
<ul>
  <li>The assignment makes circuit C output TRUE</li>
  <li>Since C computes φ, the assignment satisfies φ</li>
  <li>Therefore, φ is satisfiable</li>
</ul>

<h2 id="3-correctness-justification">3. Correctness Justification</h2>

<h3 id="31-if-sat-has-a-solution-then-circuit-design-has-a-solution">3.1 If SAT has a solution, then Circuit Design has a solution</h3>

<p><strong>Given:</strong> SAT instance φ is satisfiable with assignment A: (x₁ = a₁, …, x_n = a_n).</p>

<p><strong>Construct Circuit:</strong></p>
<ul>
  <li>Build the natural circuit for φ:
    <ul>
      <li>Input gates: x₁, …, x_n</li>
      <li>For each clause Cⱼ, create OR gate computing the clause</li>
      <li>Create AND gate combining all clause outputs</li>
    </ul>
  </li>
  <li>This circuit computes φ</li>
  <li>Circuit size: n + ∑ⱼ (<code class="language-plaintext highlighter-rouge">|Cⱼ|</code> - 1) + 1 ≤ k (by construction of k)</li>
</ul>

<p><strong>Verify Circuit:</strong></p>
<ul>
  <li>Circuit C computes φ (by construction)</li>
  <li>Circuit size ≤ k (by construction)</li>
  <li>Circuit outputs TRUE for assignment A (since A satisfies φ)</li>
  <li>Therefore, circuit C is a valid solution</li>
</ul>

<p><strong>Conclusion:</strong> Circuit Design has a solution.</p>

<h3 id="32a-if-sat-does-not-have-a-solution-then-circuit-design-has-no-solution">3.2a If SAT does not have a solution, then Circuit Design has no solution</h3>

<p><strong>Given:</strong> SAT instance φ is unsatisfiable.</p>

<p><strong>Proof by Contradiction:</strong></p>

<p>Assume Circuit Design has solution (circuit C of size ≤ k computing φ).</p>

<p><strong>Evaluate Circuit:</strong></p>
<ul>
  <li>Circuit C computes φ</li>
  <li>For any input assignment, evaluate C</li>
  <li>Since φ is unsatisfiable, C outputs FALSE for all inputs</li>
  <li>But a circuit that always outputs FALSE can be represented by a constant FALSE gate (size 1)</li>
  <li>However, we require the circuit to compute φ, not just output FALSE</li>
  <li>Actually, if φ is unsatisfiable, then φ is equivalent to FALSE</li>
  <li>A circuit computing FALSE has size 1 (just a FALSE constant)</li>
  <li>But wait: we need the circuit to compute the specific formula φ, not just its value</li>
</ul>

<p><strong>Refined Argument:</strong></p>
<ul>
  <li>If φ is unsatisfiable, then φ is logically equivalent to FALSE</li>
  <li>However, the circuit design problem asks: “Does there exist a circuit computing φ?”</li>
  <li>The answer is YES (we can always build a circuit for any formula)</li>
  <li><strong>Key Insight:</strong> We need to modify the problem to ask: “Does there exist a circuit that outputs TRUE for at least one input?”</li>
  <li>Or: “Does there exist a circuit of size ≤ k that computes φ AND outputs TRUE for some input?”</li>
</ul>

<p><strong>Corrected Problem Formulation:</strong></p>
<ul>
  <li>Circuit Design Problem (Modified): Given formula φ and size k, does there exist a circuit of size ≤ k that computes φ AND outputs TRUE for at least one input assignment?</li>
</ul>

<p><strong>With This Formulation:</strong></p>
<ul>
  <li>If φ is unsatisfiable, no circuit computing φ can output TRUE</li>
  <li>Therefore, Circuit Design has no solution</li>
</ul>

<p><strong>Conclusion:</strong> Circuit Design has no solution (with proper problem formulation).</p>

<h3 id="32b-if-circuit-design-has-a-solution-then-sat-has-a-solution">3.2b If Circuit Design has a solution, then SAT has a solution</h3>

<p><strong>Given:</strong> Circuit Design instance has solution (circuit C of size ≤ k computing φ).</p>

<p><strong>Extract SAT Solution:</strong></p>
<ul>
  <li>Circuit C computes φ</li>
  <li>Since C is a solution, it must output TRUE for at least one input (or we can find such an input)</li>
  <li>Evaluate C on all 2ⁿ inputs (or use a satisfiability checker on C)</li>
  <li>Find an input assignment A = (x₁ = a₁, …, x_n = a_n) that makes C output TRUE</li>
  <li>Since C computes φ, assignment A satisfies φ</li>
</ul>

<p><strong>Verify SAT:</strong></p>
<ul>
  <li>Assignment A makes circuit C output TRUE</li>
  <li>Since C computes φ, A satisfies φ</li>
  <li>Therefore, φ is satisfiable</li>
</ul>

<p><strong>Conclusion:</strong> SAT has a solution.</p>

<p><strong>Polynomial Time:</strong> O(n + m + L) to construct circuit specification, where L is total literals.</p>

<p><strong>Therefore, Circuit Design is NP-complete.</strong></p>

<hr />

<h2 id="key-insights">Key Insights</h2>

<ol>
  <li><strong>Formula as Circuit:</strong> Every Boolean formula naturally corresponds to a Boolean circuit</li>
  <li><strong>Satisfiability as Circuit Evaluation:</strong> Formula satisfiability is equivalent to finding an input that makes the circuit output TRUE</li>
  <li><strong>Size Constraints:</strong> The size bound k ensures the problem is non-trivial</li>
  <li><strong>Polynomial Reduction:</strong> Converting formula to circuit specification is polynomial-time</li>
</ol>

<h2 id="construction-summary">Construction Summary</h2>

<p>Given SAT instance φ in CNF:</p>
<ul>
  <li>Use same variables as inputs</li>
  <li>Specify desired function as φ</li>
  <li>Set size bound k = n + m + L + 1 (sufficient for natural circuit)</li>
  <li>Circuit Design asks: “Does there exist a circuit of size ≤ k computing φ that outputs TRUE for some input?”</li>
  <li>This is equivalent to: “Is φ satisfiable?”</li>
</ul>

<h2 id="practice-questions">Practice Questions</h2>

<ol>
  <li>
    <p><strong>Modify the problem:</strong> What if we ask for a circuit of exactly size k? How does the reduction change?</p>
  </li>
  <li>
    <p><strong>Alternative formulation:</strong> Consider Circuit Design as: “Given truth table, does there exist a circuit of size ≤ k?” How would you reduce SAT to this?</p>
  </li>
  <li>
    <p><strong>Circuit minimization:</strong> What if we ask for the minimum-size circuit? Is this still NP-complete?</p>
  </li>
  <li>
    <p><strong>Complexity:</strong> Analyze the exact polynomial time complexity of the reduction.</p>
  </li>
</ol>

<hr />

<p>This reduction demonstrates the fundamental connection between Boolean satisfiability and circuit design, showing that Circuit Design is NP-complete.</p>


        </div>

        <footer class="post-footer">
          <div class="post-navigation"><a href="/blog_algorithms/2025/11/22/reduction-rudrata-st-path-to-white-gold-path/" class="post-nav-link post-nav-prev">
                <span class="post-nav-label">← Previous</span>
                <span class="post-nav-title">Reduction: Rudrata (s,t)-Path to White and Gold Path</span>
              </a><a href="/blog_algorithms/2025/11/22/reduction-sat-to-max-sat/" class="post-nav-link post-nav-next">
                <span class="post-nav-label">Next →</span>
                <span class="post-nav-title">Reduction: SAT to Max SAT</span>
              </a></div>
        </footer>
      </article>
    </main>
  </div>

  <!-- Bottom Sections -->
  <div class="post-bottom-sections">
    <div class="bottom-section">
      <h3 class="bottom-section-title">Related Posts</h3>
      <ul class="related-posts-list"><li class="related-post-item">
                  <a href="/blog_algorithms/2025/11/22/reduction-vertex-cover-to-set-cover/" class="related-post-link">
                    <span class="related-post-title">Reduction: Vertex Cover to Set Cover</span>
                    <span class="related-post-date">Nov 22, 2025</span>
                  </a>
                </li><li class="related-post-item">
                  <a href="/blog_algorithms/2025/11/22/reduction-vertex-cover-to-hitting-set/" class="related-post-link">
                    <span class="related-post-title">Reduction: Vertex Cover to Hitting Set</span>
                    <span class="related-post-date">Nov 22, 2025</span>
                  </a>
                </li><li class="related-post-item">
                  <a href="/blog_algorithms/2025/11/22/reduction-vertex-cover-to-flower-search/" class="related-post-link">
                    <span class="related-post-title">Reduction: Vertex Cover to Flower-Search</span>
                    <span class="related-post-date">Nov 22, 2025</span>
                  </a>
                </li><li class="related-post-item">
                  <a href="/blog_algorithms/2025/11/22/reduction-vertex-cover-to-dominating-set/" class="related-post-link">
                    <span class="related-post-title">Reduction: Vertex Cover to Dominating Set</span>
                    <span class="related-post-date">Nov 22, 2025</span>
                  </a>
                </li><li class="related-post-item">
                  <a href="/blog_algorithms/2025/11/22/reduction-subset-sum-to-knapsack/" class="related-post-link">
                    <span class="related-post-title">Reduction: Subset Sum to Knapsack</span>
                    <span class="related-post-date">Nov 22, 2025</span>
                  </a>
                </li></ul>
    </div>

    <div class="bottom-section">
      <h3 class="bottom-section-title">Recent Posts</h3>
      <ul class="recent-posts-list"><li class="recent-post-item">
              <a href="/blog_algorithms/2025/11/22/reduction-vertex-cover-to-set-cover/" class="recent-post-link">
                <span class="recent-post-title">Reduction: Vertex Cover to Set Cover</span>
                <span class="recent-post-date">Nov 22, 2025</span>
              </a>
            </li><li class="recent-post-item">
              <a href="/blog_algorithms/2025/11/22/reduction-vertex-cover-to-hitting-set/" class="recent-post-link">
                <span class="recent-post-title">Reduction: Vertex Cover to Hitting Set</span>
                <span class="recent-post-date">Nov 22, 2025</span>
              </a>
            </li><li class="recent-post-item">
              <a href="/blog_algorithms/2025/11/22/reduction-vertex-cover-to-flower-search/" class="recent-post-link">
                <span class="recent-post-title">Reduction: Vertex Cover to Flower-Search</span>
                <span class="recent-post-date">Nov 22, 2025</span>
              </a>
            </li><li class="recent-post-item">
              <a href="/blog_algorithms/2025/11/22/reduction-vertex-cover-to-dominating-set/" class="recent-post-link">
                <span class="recent-post-title">Reduction: Vertex Cover to Dominating Set</span>
                <span class="recent-post-date">Nov 22, 2025</span>
              </a>
            </li><li class="recent-post-item">
              <a href="/blog_algorithms/2025/11/22/reduction-subset-sum-to-knapsack/" class="recent-post-link">
                <span class="recent-post-title">Reduction: Subset Sum to Knapsack</span>
                <span class="recent-post-date">Nov 22, 2025</span>
              </a>
            </li></ul>
    </div>
  </div>
</div>

<script>
(function() {
  // Generate Table of Contents
  function generateTOC() {
    const postContent = document.querySelector('.post-content');
    if (!postContent) return;

    const headings = postContent.querySelectorAll('h2, h3, h4');
    const tocSection = document.querySelector('.toc-section');
    
    if (headings.length === 0) {
      if (tocSection) tocSection.style.display = 'none';
      return;
    }
    
    // Show TOC section if it was hidden
    if (tocSection) tocSection.style.display = 'block';

    const tocList = document.getElementById('tocList');
    if (!tocList) return;

    let tocHTML = '';
    let lastLevel = 0; // Track the level of the last item we processed
    let openLists = 0; // Track how many nested lists are currently open

    headings.forEach((heading, index) => {
      const level = parseInt(heading.tagName.charAt(1));
      // Skip levels beyond 4 (h5, h6) - only process h2, h3, h4
      if (level > 4) return;
      
      const id = heading.id || `heading-${index}`;
      
      // Set ID if not already set
      if (!heading.id) {
        heading.id = id;
      }

      // Close previous list item (except for the first one)
      if (index > 0) {
        tocHTML += '</li>';
      }

      // Close nested lists if we're going up in level (not same level)
      while (openLists > 0 && level < lastLevel) {
        tocHTML += '</ul>';
        openLists--;
      }

      // If going deeper (and we have a previous item), open a new nested list
      // Don't open a list for the first item - it goes in the root list
      if (index > 0 && level > lastLevel) {
        tocHTML += '<ul class="toc-sublist">';
        openLists++;
      }

      // Start new list item
      const text = heading.textContent.trim();
      tocHTML += `<li class="toc-item toc-level-${level}">`;
      tocHTML += `<a href="#${id}" class="toc-link">${text}</a>`;

      lastLevel = level;
    });

    // Close all remaining open items and lists
    if (headings.length > 0) {
      tocHTML += '</li>';
    }
    while (openLists > 0) {
      tocHTML += '</ul>';
      openLists--;
    }

    tocList.innerHTML = tocHTML;

    // Add smooth scroll behavior
    tocList.querySelectorAll('a').forEach(link => {
      link.addEventListener('click', function(e) {
        e.preventDefault();
        const targetId = this.getAttribute('href').substring(1);
        const targetElement = document.getElementById(targetId);
        if (targetElement) {
          const headerOffset = 80;
          const elementPosition = targetElement.getBoundingClientRect().top;
          const offsetPosition = elementPosition + window.pageYOffset - headerOffset;

          window.scrollTo({
            top: offsetPosition,
            behavior: 'smooth'
          });

          // Update active state
          tocList.querySelectorAll('a').forEach(a => a.classList.remove('active'));
          this.classList.add('active');
        }
      });
    });

    // Highlight active section on scroll
    function updateActiveTOC() {
      const scrollPos = window.scrollY + 100;
      let current = '';

      headings.forEach(heading => {
        const headingTop = heading.offsetTop;
        if (scrollPos >= headingTop) {
          current = heading.id;
        }
      });

      tocList.querySelectorAll('a').forEach(link => {
        link.classList.remove('active');
        if (link.getAttribute('href') === '#' + current) {
          link.classList.add('active');
        }
      });
    }

    window.addEventListener('scroll', updateActiveTOC);
    updateActiveTOC();
  }

  // Run when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', generateTOC);
  } else {
    generateTOC();
  }
})();
</script>
</main><footer class="site-footer h-card">
  <data class="u-url" href="/blog_algorithms/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Robina Li</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Robina Li</li><li><a class="u-email" href="mailto:robinali34@gmail.com">robinali34@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><div class="social-links">
  <ul class="social-media-list"><li><a href="https://github.com/robinali34"><svg class="svg-icon"><use xlink:href="/blog_algorithms/assets/minima-social-icons.svg#github"></use></svg> <span class="username">robinali34</span></a></li></ul>
</div>

</div>

      <div class="footer-col footer-col-3">
        <p>Algorithms Blog - Graduate Algorithms course notes and resources</p>
      </div>
    </div>

  </div>

</footer>

</body>
</html>

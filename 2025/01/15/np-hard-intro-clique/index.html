<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>NP-Hard Introduction: The Clique Problem | Robina Li</title>
<meta name="generator" content="Jekyll v4.3.4" />
<meta property="og:title" content="NP-Hard Introduction: The Clique Problem" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="An introduction to NP-hardness through the Clique Problem, covering problem definition, NP-completeness proof via reduction from 3-SAT, and connections to other graph problems." />
<meta property="og:description" content="An introduction to NP-hardness through the Clique Problem, covering problem definition, NP-completeness proof via reduction from 3-SAT, and connections to other graph problems." />
<link rel="canonical" href="https://robinali34.github.io/blog_algorithms//blog_algorithms/2025/01/15/np-hard-intro-clique/" />
<meta property="og:url" content="https://robinali34.github.io/blog_algorithms//blog_algorithms/2025/01/15/np-hard-intro-clique/" />
<meta property="og:site_name" content="Robina Li" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-01-15T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="NP-Hard Introduction: The Clique Problem" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-01-15T00:00:00+00:00","datePublished":"2025-01-15T00:00:00+00:00","description":"An introduction to NP-hardness through the Clique Problem, covering problem definition, NP-completeness proof via reduction from 3-SAT, and connections to other graph problems.","headline":"NP-Hard Introduction: The Clique Problem","mainEntityOfPage":{"@type":"WebPage","@id":"https://robinali34.github.io/blog_algorithms//blog_algorithms/2025/01/15/np-hard-intro-clique/"},"url":"https://robinali34.github.io/blog_algorithms//blog_algorithms/2025/01/15/np-hard-intro-clique/"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/blog_algorithms/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://robinali34.github.io/blog_algorithms//blog_algorithms/feed.xml" title="Robina Li" /></head>

<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/blog_algorithms/">Robina Li</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
          <a class="page-link" href="/blog_algorithms/posts/">All Posts</a><a class="page-link" href="/blog_algorithms/about/">About</a></div>
      </nav></div>
</header>

<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">NP-Hard Introduction: The Clique Problem</h1>
    <div class="post-meta-wrapper">
      <p class="post-meta">
        <time class="dt-published" datetime="2025-01-15T00:00:00+00:00" itemprop="datePublished">Jan 15, 2025
        </time></p><div class="post-categories"><span class="category-tag">Algorithms</span><span class="category-tag">Complexity Theory</span><span class="category-tag">NP-Hard</span><span class="category-tag">CS6515</span><span class="category-tag">Graph Theory</span></div></div>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h2 id="introduction">Introduction</h2>

<p>The Clique Problem is a fundamental graph problem that plays a crucial role in understanding NP-completeness. It’s one of the classic problems used to demonstrate reduction techniques from 3-SAT and serves as a gateway to understanding many other NP-complete graph problems. In this post, we’ll explore the Clique Problem and its place in computational complexity theory.</p>

<h2 id="what-is-a-clique">What is a Clique?</h2>

<p>A <strong>clique</strong> in an undirected graph is a subset of vertices where every pair of vertices is connected by an edge. In other words, it’s a complete subgraph - a subgraph where all vertices are pairwise adjacent.</p>

<h3 id="problem-definition">Problem Definition</h3>

<p><strong>Clique Decision Problem:</strong></p>

<p><strong>Input:</strong></p>
<ul>
  <li>An undirected graph $G = (V, E)$</li>
  <li>An integer $k$</li>
</ul>

<p><strong>Output:</strong> YES if $G$ contains a clique of size at least $k$, NO otherwise</p>

<p><strong>Clique Optimization Problem:</strong></p>

<p><strong>Input:</strong> An undirected graph $G = (V, E)$</p>

<p><strong>Output:</strong> The size of the largest clique in $G$ (called the <strong>clique number</strong>, denoted $\omega(G)$)</p>

<h3 id="example">Example</h3>

<p>Consider the following graph:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    1---2
    |\ /|
    | X |
    |/ \|
    3---4
</code></pre></div></div>

<ul>
  <li>Cliques of size 2: ${1,2}, {1,3}, {1,4}, {2,3}, {2,4}, {3,4}$</li>
  <li>Cliques of size 3: ${1,2,3}, {1,2,4}, {1,3,4}, {2,3,4}$</li>
  <li>Clique of size 4: ${1,2,3,4}$ (this is a 4-clique, also called a complete graph $K_4$)</li>
</ul>

<p>So the clique number of this graph is 4.</p>

<h3 id="visual-example">Visual Example</h3>

<p>A graph with a 3-clique highlighted:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    1---2
    |   |
    3---4---5
        |
        6
</code></pre></div></div>

<p>The vertices ${1, 2, 3}$ form a clique (all pairwise connected). The vertices ${4, 5, 6}$ do NOT form a clique because 5 and 6 are not connected.</p>

<h2 id="why-clique-is-in-np">Why Clique is in NP</h2>

<p>To show that Clique is NP-complete, we first need to show it’s in NP.</p>

<p><strong>Clique ∈ NP:</strong></p>

<p>Given a candidate solution (a set of $k$ vertices), we can verify in polynomial time:</p>
<ol>
  <li>Check that the set has exactly $k$ vertices: $O(k)$ time</li>
  <li>Check that every pair of vertices in the set is connected by an edge: $O(k^2)$ time (check all $\binom{k}{2} = \frac{k(k-1)}{2}$ pairs)</li>
</ol>

<table>
  <tbody>
    <tr>
      <td>Since $k \leq</td>
      <td>V</td>
      <td>$, this verification takes polynomial time in the input size. Therefore, Clique is in NP.</td>
    </tr>
  </tbody>
</table>

<h2 id="np-completeness-reduction-from-3-sat">NP-Completeness: Reduction from 3-SAT</h2>

<p>To prove Clique is NP-complete, we need to show it’s NP-hard by reducing a known NP-complete problem to it. We’ll reduce <strong>3-SAT</strong> to Clique.</p>

<h3 id="reduction-strategy">Reduction Strategy</h3>

<p>Given a 3-SAT instance with $m$ clauses, we construct a graph $G$ such that:</p>
<ul>
  <li>The 3-SAT instance is satisfiable <strong>if and only if</strong> $G$ has a clique of size $m$</li>
</ul>

<h3 id="construction">Construction</h3>

<p>For a 3-SAT formula $\phi = C_1 \land C_2 \land \ldots \land C_m$ where each clause $C_i$ has 3 literals:</p>

<ol>
  <li><strong>Create vertices</strong>: For each literal occurrence in each clause, create a vertex
    <ul>
      <li>Label vertices as $(i, j)$ where $i$ is the clause number and $j$ is the literal position</li>
      <li>Example: For clause $C_1 = (x_1 \lor \neg x_2 \lor x_3)$, create vertices $(1,1)$ for $x_1$, $(1,2)$ for $\neg x_2$, and $(1,3)$ for $x_3$</li>
    </ul>
  </li>
  <li><strong>Add edges</strong>: Connect two vertices $(i_1, j_1)$ and $(i_2, j_2)$ with an edge if:
    <ul>
      <li>They are in <strong>different clauses</strong> ($i_1 \neq i_2$)</li>
      <li>The literals are <strong>not complementary</strong> (one is not the negation of the other)</li>
    </ul>
  </li>
  <li><strong>Set $k = m$</strong>: We’re looking for a clique of size $m$ (one vertex per clause)</li>
</ol>

<h3 id="why-this-works">Why This Works</h3>

<p><strong>Intuition:</strong></p>
<ul>
  <li>A clique of size $m$ means we pick one literal from each clause</li>
  <li>Since vertices in different clauses are connected only if literals are not complementary, a clique ensures we never pick both $x$ and $\neg x$</li>
  <li>Therefore, a clique corresponds to a satisfying assignment</li>
</ul>

<p><strong>Formal Proof:</strong></p>

<p><strong>Forward Direction (3-SAT satisfiable → Clique exists):</strong></p>
<ul>
  <li>If $\phi$ is satisfiable, there exists an assignment that makes at least one literal true in each clause</li>
  <li>Pick the vertex corresponding to that true literal from each clause</li>
  <li>These $m$ vertices form a clique because:
    <ul>
      <li>They’re from different clauses (so edges exist by construction)</li>
      <li>They can’t be complementary (both can’t be true simultaneously)</li>
    </ul>
  </li>
</ul>

<p><strong>Reverse Direction (Clique exists → 3-SAT satisfiable):</strong></p>
<ul>
  <li>If there’s a clique of size $m$, we have one vertex (literal) from each clause</li>
  <li>Set variables to make these literals true:
    <ul>
      <li>If literal is $x_i$, set $x_i = \text{TRUE}$</li>
      <li>If literal is $\neg x_i$, set $x_i = \text{FALSE}$</li>
    </ul>
  </li>
  <li>Since no complementary literals are in the clique, this assignment is consistent</li>
  <li>This assignment satisfies all clauses</li>
</ul>

<h3 id="example-reduction">Example Reduction</h3>

<p>Consider the 3-SAT instance:
\(\phi = (x_1 \lor x_2 \lor x_3) \land (\neg x_1 \lor x_2 \lor \neg x_3) \land (x_1 \lor \neg x_2 \lor x_3)\)</p>

<p><strong>Step 1: Create vertices</strong></p>
<ul>
  <li>Clause 1: $(1,1)$ for $x_1$, $(1,2)$ for $x_2$, $(1,3)$ for $x_3$</li>
  <li>Clause 2: $(2,1)$ for $\neg x_1$, $(2,2)$ for $x_2$, $(2,3)$ for $\neg x_3$</li>
  <li>Clause 3: $(3,1)$ for $x_1$, $(3,2)$ for $\neg x_2$, $(3,3)$ for $x_3$</li>
</ul>

<p><strong>Step 2: Add edges</strong></p>
<ul>
  <li>Connect vertices from different clauses if literals are not complementary</li>
  <li>For example: $(1,1)$ (represents $x_1$) connects to $(2,2)$ ($x_2$) and $(2,3)$ ($\neg x_3$) and $(3,1)$ ($x_1$) and $(3,2)$ ($\neg x_2$) and $(3,3)$ ($x_3$)</li>
  <li>But $(1,1)$ does NOT connect to $(2,1)$ because $x_1$ and $\neg x_1$ are complementary</li>
  <li>Similarly, $(1,3)$ does NOT connect to $(2,3)$ because $x_3$ and $\neg x_3$ are complementary</li>
</ul>

<p><strong>Step 3: Find clique of size 3</strong></p>
<ul>
  <li>One possible clique: ${(1,2), (2,2), (3,3)}$ representing $x_2$ from clause 1, $x_2$ from clause 2, and $x_3$ from clause 3</li>
  <li>This corresponds to assignment: $x_1 = \text{TRUE}$ (arbitrary), $x_2 = \text{TRUE}$, $x_3 = \text{TRUE}$</li>
  <li>Verify: All clauses satisfied!</li>
</ul>

<h2 id="relationship-to-other-graph-problems">Relationship to Other Graph Problems</h2>

<p>The Clique Problem is closely related to several other NP-complete problems:</p>

<h3 id="independent-set">Independent Set</h3>

<p>An <strong>independent set</strong> is a set of vertices where no two are adjacent (opposite of a clique).</p>

<p><strong>Key Relationship:</strong></p>
<ul>
  <li>$S$ is a clique in $G$ <strong>if and only if</strong> $S$ is an independent set in $\overline{G}$ (the complement graph)</li>
  <li>Therefore, Clique and Independent Set are polynomially equivalent</li>
</ul>

<h3 id="vertex-cover">Vertex Cover</h3>

<p>A <strong>vertex cover</strong> is a set of vertices that covers all edges (every edge has at least one endpoint in the set).</p>

<p><strong>Key Relationship:</strong></p>
<ul>
  <li>$S$ is an independent set <strong>if and only if</strong> $V \setminus S$ is a vertex cover</li>
  <li>This connects Clique to Vertex Cover through Independent Set</li>
</ul>

<h3 id="graph-coloring">Graph Coloring</h3>

<p>The <strong>chromatic number</strong> $\chi(G)$ is the minimum number of colors needed to color vertices so no adjacent vertices share a color.</p>

<p><strong>Key Relationship:</strong></p>
<ul>
  <li>$\omega(G) \leq \chi(G)$ (clique number is a lower bound for chromatic number)</li>
  <li>Finding the clique number helps bound the chromatic number</li>
</ul>

<h2 id="practical-implications">Practical Implications</h2>

<h3 id="why-clique-is-hard">Why Clique is Hard</h3>

<p>The Clique Problem is NP-complete, which means:</p>

<ol>
  <li><strong>No Known Polynomial-Time Algorithm</strong>: Best known algorithms have exponential time complexity</li>
  <li><strong>Brute Force</strong>: Check all $\binom{n}{k}$ subsets of size $k$ - exponential in $k$</li>
  <li><strong>Dynamic Programming</strong>: Can solve in $O(2^n \cdot n^2)$ time using inclusion-exclusion or bitmask DP</li>
  <li><strong>Branch and Bound</strong>: Practical for small instances, but still exponential worst-case</li>
</ol>

<h3 id="approximation">Approximation</h3>

<p>The Clique Problem is particularly difficult to approximate:</p>

<ul>
  <li><strong>No PTAS</strong>: Unless P = NP, there is no polynomial-time approximation scheme</li>
  <li><strong>Hard to Approximate</strong>: Cannot be approximated within $n^{1-\epsilon}$ for any $\epsilon &gt; 0$ (unless P = NP)</li>
  <li>This makes Clique one of the hardest problems to approximate</li>
</ul>

<h3 id="real-world-applications">Real-World Applications</h3>

<p>Despite being NP-complete, clique-finding has applications:</p>

<ol>
  <li><strong>Social Networks</strong>: Finding communities (groups where everyone knows everyone)</li>
  <li><strong>Bioinformatics</strong>: Finding protein complexes, gene clusters</li>
  <li><strong>Data Mining</strong>: Finding dense subgraphs in networks</li>
  <li><strong>Cryptography</strong>: Some cryptographic protocols rely on clique hardness</li>
  <li><strong>Network Analysis</strong>: Identifying tightly-knit groups in communication networks</li>
</ol>

<h3 id="special-cases">Special Cases</h3>

<p>Some restricted versions of Clique are tractable:</p>

<ul>
  <li><strong>Planar Graphs</strong>: Clique is polynomial-time solvable (maximum clique size is at most 4)</li>
  <li><strong>Bounded Treewidth</strong>: Can be solved efficiently using tree decomposition</li>
  <li><strong>Interval Graphs</strong>: Polynomial-time algorithms exist</li>
  <li><strong>Perfect Graphs</strong>: Clique and coloring can be solved in polynomial time</li>
</ul>

<h2 id="runtime-analysis">Runtime Analysis</h2>

<h3 id="brute-force-approach">Brute Force Approach</h3>

<p><strong>Algorithm:</strong> Check all $\binom{n}{k}$ subsets of size $k$</p>
<ul>
  <li><strong>Time Complexity:</strong> $O(\binom{n}{k} \cdot k^2) = O(n^k \cdot k^2)$</li>
  <li><strong>Space Complexity:</strong> $O(k)$ for storing current subset</li>
  <li><strong>Analysis:</strong> For each subset, check all $\binom{k}{2}$ pairs of vertices for edges</li>
</ul>

<h3 id="dynamic-programming">Dynamic Programming</h3>

<p><strong>Algorithm:</strong> Use bitmask DP to track visited vertices</p>
<ul>
  <li><strong>Time Complexity:</strong> $O(2^n \cdot n^2)$</li>
  <li><strong>Space Complexity:</strong> $O(2^n \cdot n)$</li>
  <li><strong>Subproblem:</strong> $dp[mask][v]$ = true if there exists a clique in vertices $mask$ ending at $v$</li>
  <li><strong>Recurrence:</strong> $dp[mask][v] = \bigvee_{u \in mask, (u,v) \in E} dp[mask \setminus {v}][u]$</li>
</ul>

<h3 id="branch-and-bound">Branch-and-Bound</h3>

<p><strong>Algorithm:</strong> Systematic search with pruning</p>
<ul>
  <li><strong>Time Complexity:</strong> Exponential worst-case, but better than brute force with good pruning</li>
  <li><strong>Space Complexity:</strong> $O(n)$ for recursion stack</li>
  <li><strong>Pruning:</strong> Stop exploring branches that can’t lead to clique of size $k$</li>
</ul>

<h3 id="bron-kerbosch-algorithm-maximum-clique">Bron-Kerbosch Algorithm (Maximum Clique)</h3>

<p><strong>Algorithm:</strong> Recursive backtracking for finding all maximal cliques</p>
<ul>
  <li><strong>Time Complexity:</strong> $O(3^{n/3})$ worst-case (tight bound)</li>
  <li><strong>Space Complexity:</strong> $O(n)$</li>
  <li><strong>Practical Performance:</strong> Very efficient for sparse graphs</li>
</ul>

<h3 id="verification-complexity">Verification Complexity</h3>

<p><strong>Given a candidate clique of size $k$:</strong></p>
<ul>
  <li><strong>Time Complexity:</strong> $O(k^2)$ - check all pairs</li>
  <li><strong>Space Complexity:</strong> $O(1)$ additional space</li>
  <li>This polynomial-time verifiability shows Clique is in NP</li>
</ul>

<h2 id="key-takeaways">Key Takeaways</h2>

<ol>
  <li><strong>Clique is NP-Complete</strong>: Proven by reduction from 3-SAT</li>
  <li><strong>Reduction Pattern</strong>: The 3-SAT → Clique reduction is a classic example showing how to encode logical constraints as graph structures</li>
  <li><strong>Graph Problem Relationships</strong>: Clique is closely related to Independent Set, Vertex Cover, and Graph Coloring</li>
  <li><strong>Hard to Approximate</strong>: Clique is particularly difficult to approximate, making it a benchmark for approximation hardness</li>
  <li><strong>Practical Algorithms</strong>: Despite NP-completeness, various techniques (DP, branch-and-bound, heuristics) work well for many practical instances</li>
</ol>

<h2 id="reduction-summary">Reduction Summary</h2>

<p><strong>3-SAT ≤ₚ Clique:</strong></p>
<ul>
  <li>Given 3-SAT instance with $m$ clauses</li>
  <li>Create graph with vertices for each literal occurrence</li>
  <li>Connect vertices from different clauses if literals are not complementary</li>
  <li>3-SAT satisfiable ↔ Graph has clique of size $m$</li>
</ul>

<p>This reduction is polynomial-time because:</p>
<ul>
  <li>Number of vertices: $3m$ (at most)</li>
  <li>Number of edges: $O(m^2)$ (check all pairs)</li>
  <li>Construction time: Polynomial in input size</li>
</ul>

<h2 id="further-reading">Further Reading</h2>

<ul>
  <li><strong>Garey &amp; Johnson</strong>: “Computers and Intractability” - Standard reference for NP-completeness proofs</li>
  <li><strong>Approximation Hardness</strong>: Research on why Clique is hard to approximate</li>
  <li><strong>Perfect Graphs</strong>: Special graph classes where Clique is tractable</li>
  <li><strong>Social Network Analysis</strong>: Applications of clique detection in real networks</li>
</ul>

<h2 id="practice-problems">Practice Problems</h2>

<ol>
  <li>
    <p><strong>Construct the graph</strong> for the 3-SAT instance:
\((x_1 \lor x_2 \lor \neg x_3) \land (\neg x_1 \lor x_2 \lor x_3) \land (x_1 \lor \neg x_2 \lor x_3)\)
Find a clique of size 3 and determine the corresponding satisfying assignment.</p>
  </li>
  <li>
    <p><strong>Prove the relationship</strong>: Show that $S$ is a clique in $G$ if and only if $S$ is an independent set in $\overline{G}$ (the complement graph).</p>
  </li>
  <li>
    <p><strong>Reduction practice</strong>: Given that Clique is NP-complete, show that Independent Set is also NP-complete using the complement graph relationship.</p>
  </li>
  <li>
    <p><strong>Algorithm design</strong>: Design a dynamic programming algorithm to find the maximum clique size in a graph. What is its time complexity?</p>
  </li>
  <li>
    <p><strong>Special cases</strong>: Research why the Clique problem is polynomial-time solvable for planar graphs. What is the maximum clique size possible in a planar graph?</p>
  </li>
</ol>

<hr />

<p>Understanding the Clique Problem and its NP-completeness proof provides crucial insight into reduction techniques and the interconnected nature of NP-complete problems. The 3-SAT → Clique reduction is a fundamental example that demonstrates how logical constraints can be encoded as graph structures.</p>


  </div>

  <footer class="post-footer">
    <div class="post-navigation">
      <a href="/blog_algorithms/posts/" class="back-to-posts">← Back to All Posts</a>
    </div>
  </footer><a class="u-url" href="/blog_algorithms/2025/01/15/np-hard-intro-clique/" hidden></a>
</article>


      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/blog_algorithms/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Robina Li</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Robina Li</li><li><a class="u-email" href="mailto:robinali34@gmail.com">robinali34@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><div class="social-links">
  <ul class="social-media-list"><li><a href="https://github.com/robinali34"><svg class="svg-icon"><use xlink:href="/blog_algorithms/assets/minima-social-icons.svg#github"></use></svg> <span class="username">robinali34</span></a></li></ul>
</div>

</div>

      <div class="footer-col footer-col-3">
        <p>CS6515 Blog - Graduate Algorithms course notes and resources</p>
      </div>
    </div>

  </div>

</footer>

</body>

</html>


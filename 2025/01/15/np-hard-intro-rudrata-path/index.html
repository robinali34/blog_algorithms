<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>NP-Hard Introduction: Rudrata Path and Rudrata (s,t)-Path | Robina Li</title>
<meta name="generator" content="Jekyll v4.3.4" />
<meta property="og:title" content="NP-Hard Introduction: Rudrata Path and Rudrata (s,t)-Path" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="An introduction to NP-hardness through the Rudrata Path and Rudrata (s,t)-Path problems, covering problem definitions, NP-completeness proofs, and connections to Hamiltonian Cycle." />
<meta property="og:description" content="An introduction to NP-hardness through the Rudrata Path and Rudrata (s,t)-Path problems, covering problem definitions, NP-completeness proofs, and connections to Hamiltonian Cycle." />
<link rel="canonical" href="https://robinali34.github.io/blog_algorithms//blog_algorithms/2025/01/15/np-hard-intro-rudrata-path/" />
<meta property="og:url" content="https://robinali34.github.io/blog_algorithms//blog_algorithms/2025/01/15/np-hard-intro-rudrata-path/" />
<meta property="og:site_name" content="Robina Li" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-01-15T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="NP-Hard Introduction: Rudrata Path and Rudrata (s,t)-Path" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-01-15T00:00:00+00:00","datePublished":"2025-01-15T00:00:00+00:00","description":"An introduction to NP-hardness through the Rudrata Path and Rudrata (s,t)-Path problems, covering problem definitions, NP-completeness proofs, and connections to Hamiltonian Cycle.","headline":"NP-Hard Introduction: Rudrata Path and Rudrata (s,t)-Path","mainEntityOfPage":{"@type":"WebPage","@id":"https://robinali34.github.io/blog_algorithms//blog_algorithms/2025/01/15/np-hard-intro-rudrata-path/"},"url":"https://robinali34.github.io/blog_algorithms//blog_algorithms/2025/01/15/np-hard-intro-rudrata-path/"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/blog_algorithms/assets/main.css">
  <link rel="stylesheet" href="/blog_algorithms/assets/css/morandi-theme.css"><link type="application/atom+xml" rel="alternate" href="https://robinali34.github.io/blog_algorithms//blog_algorithms/feed.xml" title="Robina Li" /></head>

<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/blog_algorithms/">Robina Li</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
          <a class="page-link" href="/blog_algorithms/posts/">All Posts</a><a class="page-link" href="/blog_algorithms/about/">About</a></div>
      </nav></div>
</header>

<main class="page-content" aria-label="Content"><div class="post-container">

  <div class="post-wrapper">
    <!-- Left Sidebar - Table of Contents -->
    <aside class="post-sidebar-left">
      <div class="sidebar-section toc-section">
        <h3 class="sidebar-title">Table of Contents</h3>
        <nav class="toc-nav" id="tableOfContents">
          <ul class="toc-list" id="tocList">
            <!-- Generated by JavaScript -->
          </ul>
        </nav>
      </div>
    </aside>

    <!-- Main Content -->
    <main class="post-main">
      <article class="post">
        <header class="post-header-content">
          <h1 class="post-title">NP-Hard Introduction: Rudrata Path and Rudrata (s,t)-Path</h1>
          <div class="post-meta-info">
            <time class="post-date" datetime="2025-01-15T00:00:00+00:00">
              January 15, 2025
            </time><div class="post-categories"><span class="category-tag">Algorithms</span><span class="category-tag">Complexity Theory</span><span class="category-tag">NP-Hard</span><span class="category-tag">Graph Theory</span></div></div>
        </header>

        <div class="post-content">
          <h2 id="introduction">Introduction</h2>

<p>The Rudrata Path Problem (also known as the Hamiltonian Path Problem) is a fundamental graph problem that asks whether a graph contains a path visiting every vertex exactly once. The Rudrata (s,t)-Path Problem is a variant that requires the path to start at a specific vertex s and end at a specific vertex t. These problems are closely related to the Hamiltonian Cycle Problem and serve as excellent examples of NP-completeness in graph theory.</p>

<h2 id="what-is-a-rudrata-path">What is a Rudrata Path?</h2>

<p>A <strong>Rudrata path</strong> (also called a <strong>Hamiltonian path</strong>) in an undirected graph is a path that visits each vertex exactly once. Unlike a cycle, a path doesn’t need to return to the starting vertex.</p>

<h3 id="problem-definitions">Problem Definitions</h3>

<p><strong>Rudrata Path Decision Problem:</strong></p>

<p><strong>Input:</strong></p>
<ul>
  <li>An undirected graph G = (V, E)</li>
</ul>

<p><strong>Output:</strong> YES if G contains a Rudrata path (a path visiting every vertex exactly once), NO otherwise</p>

<p><strong>Rudrata (s,t)-Path Decision Problem:</strong></p>

<p><strong>Input:</strong></p>
<ul>
  <li>An undirected graph G = (V, E)</li>
  <li>Two vertices s, t ∈ V</li>
</ul>

<p><strong>Output:</strong> YES if G contains a Rudrata path starting at s and ending at t, NO otherwise</p>

<h3 id="example">Example</h3>

<p>Consider the following graph:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    1---2---3
    |   |   |
    4---5---6
</code></pre></div></div>

<p><strong>Rudrata Path:</strong></p>
<ul>
  <li>Path: 1 → 4 → 5 → 2 → 3 → 6 ✓ (visits all 6 vertices exactly once)</li>
  <li>Path: 1 → 2 → 5 → 4 ✗ (doesn’t visit all vertices)</li>
  <li>Path: 1 → 2 → 3 → 2 ✗ (visits vertex 2 twice)</li>
</ul>

<p><strong>Rudrata (1,6)-Path:</strong></p>
<ul>
  <li>Path: 1 → 4 → 5 → 2 → 3 → 6 ✓ (starts at 1, ends at 6, visits all vertices)</li>
  <li>Path: 1 → 2 → 5 → 4 → 3 → 6 ✓ (another valid (1,6)-path)</li>
</ul>

<h3 id="visual-example">Visual Example</h3>

<p>A graph with a Rudrata path highlighted:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    1---2
    |\ /|
    | X |
    |/ \|
    3---4
</code></pre></div></div>

<ul>
  <li>Rudrata path: 1 → 2 → 4 → 3 (visits all 4 vertices)</li>
  <li>Note: This graph also has a Hamiltonian cycle: 1 → 2 → 4 → 3 → 1</li>
</ul>

<h2 id="why-rudrata-path-is-in-np">Why Rudrata Path is in NP</h2>

<p>To show that Rudrata Path is NP-complete, we first need to show it’s in NP.</p>

<p><strong>Rudrata Path ∈ NP:</strong></p>

<p>Given a candidate solution (a sequence of vertices representing a path), we can verify in polynomial time:</p>
<ol>
  <li>
    <table>
      <tbody>
        <tr>
          <td>Check that the path has exactly</td>
          <td>V</td>
          <td>vertices: O(</td>
          <td>V</td>
          <td>) time</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>Check that each vertex appears exactly once: O(</td>
          <td>V</td>
          <td>) time (use a set or array)</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>Check that consecutive vertices in the path are adjacent: O(</td>
          <td>V</td>
          <td>) time (check</td>
          <td>V</td>
          <td>-1 edges)</td>
        </tr>
      </tbody>
    </table>
  </li>
</ol>

<table>
  <tbody>
    <tr>
      <td>Total verification time: O(</td>
      <td>V</td>
      <td>), which is polynomial in the input size. Therefore, Rudrata Path is in NP.</td>
    </tr>
  </tbody>
</table>

<p>Similarly, <strong>Rudrata (s,t)-Path ∈ NP</strong> with the additional checks:</p>
<ul>
  <li>First vertex is s</li>
  <li>Last vertex is t</li>
</ul>

<h2 id="np-completeness-reduction-from-hamiltonian-cycle">NP-Completeness: Reduction from Hamiltonian Cycle</h2>

<p>The most elegant proof that Rudrata Path is NP-complete reduces from the <strong>Hamiltonian Cycle Problem</strong>.</p>

<h3 id="hamiltonian-cycle-problem">Hamiltonian Cycle Problem</h3>

<p><strong>Hamiltonian Cycle:</strong></p>
<ul>
  <li><strong>Input:</strong> An undirected graph G = (V, E)</li>
  <li><strong>Output:</strong> YES if G contains a cycle visiting every vertex exactly once, NO otherwise</li>
</ul>

<p>Hamiltonian Cycle is known to be NP-complete (can be proven by reduction from 3-SAT).</p>

<h3 id="reduction-from-hamiltonian-cycle-to-rudrata-path">Reduction from Hamiltonian Cycle to Rudrata Path</h3>

<p><strong>Reduction:</strong></p>
<ol>
  <li>Given a Hamiltonian Cycle instance: graph G = (V, E)</li>
  <li>Pick an arbitrary vertex v ∈ V</li>
  <li>Create graph G’ by:
    <ul>
      <li>Adding a new vertex v’ (copy of v)</li>
      <li>Connecting v’ to all neighbors of v</li>
      <li>Removing vertex v (or equivalently, work with G’ having v’ instead)</li>
    </ul>
  </li>
  <li>Return Rudrata Path instance: graph G’</li>
</ol>

<p><strong>Alternative Simpler Reduction:</strong></p>
<ol>
  <li>Given Hamiltonian Cycle instance: graph G</li>
  <li>Pick an arbitrary edge (u, v) ∈ E</li>
  <li>Create graph G’ by removing edge (u, v) and adding two new vertices s and t</li>
  <li>Connect s only to u and t only to v</li>
  <li>Return Rudrata (s,t)-Path instance: graph G’ with start s and end t</li>
</ol>

<p><strong>Correctness:</strong></p>
<ul>
  <li>If G has a Hamiltonian cycle, we can break it at edge (u,v) to get a path from u to v visiting all original vertices</li>
  <li>Add s at the start and t at the end to get a Rudrata (s,t)-path</li>
  <li>If G’ has a Rudrata (s,t)-path, it must go s → u → … → v → t</li>
  <li>Removing s and t and adding edge (u,v) gives a Hamiltonian cycle in G</li>
</ul>

<p><strong>Polynomial Time:</strong></p>
<ul>
  <li>
    <table>
      <tbody>
        <tr>
          <td>The reduction takes O(</td>
          <td>V</td>
          <td>+</td>
          <td>E</td>
          <td>) time</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<p>Therefore, <strong>Rudrata Path and Rudrata (s,t)-Path are NP-complete</strong>.</p>

<h2 id="alternative-reduction-direct-from-3-sat">Alternative Reduction: Direct from 3-SAT</h2>

<p>We can also prove Rudrata (s,t)-Path is NP-complete by directly reducing from 3-SAT, similar to other graph problems.</p>

<h3 id="construction">Construction</h3>

<p>For a 3-SAT formula φ = C₁ ∧ C₂ ∧ … ∧ Cₘ with variables x₁, x₂, …, xₙ:</p>

<p><strong>Key Idea:</strong> Create a graph where a Rudrata (s,t)-path corresponds to a satisfying assignment.</p>

<ol>
  <li><strong>For each variable xᵢ:</strong>
    <ul>
      <li>Create a “variable gadget”: a path with vertices representing choosing xᵢ = TRUE or xᵢ = FALSE</li>
      <li>Typically: vertices vᵢ,₁, vᵢ,₂, …, vᵢ,ₖ where the path can go “left” (TRUE) or “right” (FALSE)</li>
    </ul>
  </li>
  <li><strong>For each clause Cⱼ:</strong>
    <ul>
      <li>Create a “clause gadget”: vertices that can be visited if the clause is satisfied</li>
      <li>Connect clause vertices to variable vertices corresponding to literals in the clause</li>
    </ul>
  </li>
  <li><strong>Connect gadgets:</strong>
    <ul>
      <li>Chain variable gadgets together</li>
      <li>Connect clause gadgets appropriately</li>
      <li>Ensure a Rudrata (s,t)-path visits all vertices exactly once</li>
    </ul>
  </li>
  <li><strong>Set s and t:</strong> Start and end vertices of the constructed graph</li>
</ol>

<h3 id="why-this-works">Why This Works</h3>

<p><strong>Intuition:</strong></p>
<ul>
  <li>A Rudrata (s,t)-path must visit all vertices exactly once</li>
  <li>The path through variable gadgets encodes a truth assignment</li>
  <li>The path can only visit clause vertices if corresponding literals are true</li>
  <li>A valid path exists if and only if the formula is satisfiable</li>
</ul>

<p><strong>Formal Proof:</strong></p>

<p><strong>Forward Direction (3-SAT satisfiable → Rudrata (s,t)-Path exists):</strong></p>
<ul>
  <li>If φ is satisfiable, construct path through variable gadgets based on assignment</li>
  <li>Visit clause vertices for satisfied clauses</li>
  <li>This gives a valid Rudrata (s,t)-path</li>
</ul>

<p><strong>Reverse Direction (Rudrata (s,t)-Path exists → 3-SAT satisfiable):</strong></p>
<ul>
  <li>Extract truth assignment from path through variable gadgets</li>
  <li>Since all clause vertices are visited, each clause has at least one true literal</li>
  <li>This gives a satisfying assignment</li>
</ul>

<h2 id="relationship-between-rudrata-path-variants">Relationship Between Rudrata Path Variants</h2>

<h3 id="rudrata-path-vs-rudrata-st-path">Rudrata Path vs Rudrata (s,t)-Path</h3>

<p><strong>Rudrata (s,t)-Path ≤ₚ Rudrata Path:</strong></p>
<ul>
  <li>Given Rudrata (s,t)-Path instance: graph G, vertices s and t</li>
  <li>Add two new vertices s’ and t’</li>
  <li>Connect s’ only to s and t’ only to t</li>
  <li>Return Rudrata Path instance: modified graph</li>
  <li>Rudrata (s,t)-path exists ↔ Rudrata path exists (must start at s’ and end at t’)</li>
</ul>

<p><strong>Rudrata Path ≤ₚ Rudrata (s,t)-Path:</strong></p>
<ul>
  <li>Given Rudrata Path instance: graph G</li>
  <li>Pick arbitrary vertices s and t</li>
  <li>Try all pairs (s,t) or use a more clever reduction</li>
  <li>Actually, we can reduce by trying all pairs, but this is not polynomial</li>
  <li>Better: Add two vertices connected only to all original vertices, then require path between them</li>
</ul>

<h3 id="relationship-to-hamiltonian-cycle">Relationship to Hamiltonian Cycle</h3>

<p>As we saw:</p>
<ul>
  <li><strong>Hamiltonian Cycle ≤ₚ Rudrata Path</strong>: Break cycle into path</li>
  <li><strong>Rudrata Path ≤ₚ Hamiltonian Cycle</strong>: Add edges to connect path ends</li>
</ul>

<p>They are polynomially equivalent.</p>

<h2 id="practical-implications">Practical Implications</h2>

<h3 id="why-rudrata-path-is-hard">Why Rudrata Path is Hard</h3>

<p>The Rudrata Path Problem is NP-complete, which means:</p>

<ol>
  <li><strong>No Known Polynomial-Time Algorithm</strong>: Best known algorithms have exponential time complexity</li>
  <li><strong>Brute Force</strong>: Try all n! permutations of vertices - factorial time</li>
  <li><strong>Dynamic Programming</strong>: Can solve in O(2ⁿ · n²) time using bitmask DP (similar to TSP)</li>
  <li><strong>Backtracking</strong>: Practical for small instances, but still exponential worst-case</li>
</ol>

<h3 id="dynamic-programming-solution">Dynamic Programming Solution</h3>

<p><strong>Subproblem:</strong> dp[mask][v] = true if there exists a path visiting all vertices in mask ending at vertex v.</p>

<p><strong>Recurrence:</strong></p>
<ul>
  <li>Base case: dp[2ⁱ][i] = true for all i (path of length 1)</li>
  <li>Recurrence: dp[mask][v] = ∨(u ∈ mask, (u,v) ∈ E) dp[mask \ {v}][u]
    <ul>
      <li>Path ending at v visiting vertices in mask exists if there’s a neighbor u such that path ending at u visiting mask \ {v} exists</li>
    </ul>
  </li>
</ul>

<p><strong>Algorithm:</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Algorithm: RudrataPathDP(G)
1. n = |V|
2. Let dp[0..2^n-1][0..n-1] be a boolean array
3. for i = 0 to n-1:
4.     dp[2^i][i] = true
5. for mask = 1 to 2^n - 1:
6.     for v = 0 to n-1:
7.         if v in mask:
8.             for each neighbor u of v:
9.                 if u in mask:
10.                    dp[mask][v] = dp[mask][v] OR dp[mask - 2^v][u]
11. for v = 0 to n-1:
12.     if dp[2^n - 1][v]:
13.         return true
14. return false
</code></pre></div></div>

<p><strong>Time Complexity:</strong> O(2ⁿ · n²)
<strong>Space Complexity:</strong> O(2ⁿ · n)</p>

<h2 id="runtime-analysis">Runtime Analysis</h2>

<h3 id="brute-force-approach">Brute Force Approach</h3>

<p><strong>Algorithm:</strong> Try all n! permutations of vertices</p>
<ul>
  <li><strong>Time Complexity:</strong> O(n! · n)</li>
  <li><strong>Space Complexity:</strong> O(n) for storing current path</li>
  <li><strong>Analysis:</strong> For each permutation, verify it forms a valid path (O(n) checks)</li>
</ul>

<h3 id="dynamic-programming-held-karp-style">Dynamic Programming (Held-Karp Style)</h3>

<p><strong>Algorithm:</strong> Bitmask DP as described above</p>
<ul>
  <li><strong>Time Complexity:</strong> O(2ⁿ · n²)</li>
  <li><strong>Space Complexity:</strong> O(2ⁿ · n) (can be optimized with careful implementation)</li>
  <li><strong>Subproblem:</strong> dp[mask][v] = true if path exists visiting all vertices in mask ending at v</li>
  <li><strong>Recurrence:</strong> dp[mask][v] = ∨(u ∈ mask, (u,v) ∈ E) dp[mask \ {v}][u]</li>
</ul>

<h3 id="backtracking">Backtracking</h3>

<p><strong>Algorithm:</strong> Systematic search with pruning</p>
<ul>
  <li><strong>Time Complexity:</strong> Exponential worst-case, but better than brute force with pruning</li>
  <li><strong>Space Complexity:</strong> O(n) for recursion stack</li>
  <li><strong>Pruning:</strong> Stop if current path can’t be extended to visit all vertices</li>
</ul>

<h3 id="special-cases">Special Cases</h3>

<p><strong>Trees:</strong></p>
<ul>
  <li><strong>Time Complexity:</strong> O(n) - any path covering all vertices works</li>
  <li><strong>Space Complexity:</strong> O(n)</li>
</ul>

<p><strong>Complete Graphs:</strong></p>
<ul>
  <li><strong>Time Complexity:</strong> O(1) - any permutation works, trivial to find</li>
</ul>

<h3 id="verification-complexity">Verification Complexity</h3>

<p><strong>Given a candidate path:</strong></p>
<ul>
  <li><strong>Time Complexity:</strong> O(n) - verify all n-1 edges exist and all vertices appear once</li>
  <li><strong>Space Complexity:</strong> O(1) additional space</li>
  <li>This polynomial-time verifiability shows Rudrata Path is in NP</li>
</ul>

<h3 id="real-world-applications">Real-World Applications</h3>

<p>Rudrata Path has numerous applications:</p>

<ol>
  <li><strong>Route Planning</strong>: Finding routes that visit all locations exactly once</li>
  <li><strong>Circuit Design</strong>: Designing circuits that visit all components</li>
  <li><strong>DNA Sequencing</strong>: Finding paths through overlap graphs</li>
  <li><strong>Network Analysis</strong>: Analyzing connectivity and reachability</li>
  <li><strong>Game Theory</strong>: Solving puzzles like the “traveling” variants</li>
  <li><strong>Scheduling</strong>: Sequencing tasks with dependencies</li>
</ol>

<h3 id="special-cases-1">Special Cases</h3>

<p>Some restricted versions of Rudrata Path are tractable:</p>

<ul>
  <li><strong>Trees</strong>: Always has a Rudrata path (any path covering all vertices)</li>
  <li><strong>Complete Graphs</strong>: Always has a Rudrata path (any permutation works)</li>
  <li><strong>Path Graphs</strong>: Trivial (the graph itself is a Rudrata path)</li>
  <li><strong>Grid Graphs</strong>: Can be solved efficiently for certain grid structures</li>
  <li><strong>Bounded Treewidth</strong>: Can be solved efficiently using tree decomposition</li>
</ul>

<h2 id="key-takeaways">Key Takeaways</h2>

<ol>
  <li><strong>Rudrata Path is NP-Complete</strong>: Proven by reduction from Hamiltonian Cycle or directly from 3-SAT</li>
  <li><strong>Two Variants</strong>: Rudrata Path (any start/end) and Rudrata (s,t)-Path (fixed start/end) are polynomially equivalent</li>
  <li><strong>Hamiltonian Cycle Connection</strong>: Rudrata Path and Hamiltonian Cycle are closely related and polynomially equivalent</li>
  <li><strong>Dynamic Programming</strong>: O(2ⁿ · n²) time solution using bitmask DP works for small graphs</li>
  <li><strong>Practical Algorithms</strong>: Despite NP-completeness, DP and backtracking work well for many practical instances</li>
</ol>

<h2 id="reduction-summary">Reduction Summary</h2>

<p><strong>Hamiltonian Cycle ≤ₚ Rudrata (s,t)-Path:</strong></p>
<ul>
  <li>Given Hamiltonian Cycle instance: graph G</li>
  <li>Pick edge (u,v), remove it, add vertices s and t</li>
  <li>Connect s to u and t to v</li>
  <li>Hamiltonian cycle exists ↔ Rudrata (s,t)-path exists</li>
</ul>

<p><strong>Rudrata (s,t)-Path ≤ₚ Rudrata Path:</strong></p>
<ul>
  <li>Add vertices s’ and t’ connected only to s and t respectively</li>
  <li>Rudrata (s,t)-path exists ↔ Rudrata path exists (must use s’ and t’)</li>
</ul>

<p><strong>3-SAT ≤ₚ Rudrata (s,t)-Path:</strong></p>
<ul>
  <li>Construct graph with variable and clause gadgets</li>
  <li>Satisfying assignment ↔ Rudrata (s,t)-path</li>
</ul>

<p>All reductions are polynomial-time, establishing both problems as NP-complete.</p>

<h2 id="further-reading">Further Reading</h2>

<ul>
  <li><strong>Garey &amp; Johnson</strong>: “Computers and Intractability” - Standard reference for NP-completeness proofs</li>
  <li><strong>Hamiltonian Cycle</strong>: Understanding the relationship between path and cycle problems</li>
  <li><strong>Dynamic Programming</strong>: CLRS covers bitmask DP techniques for TSP and related problems</li>
  <li><strong>Graph Algorithms</strong>: Books on graph algorithms cover special cases and heuristics</li>
</ul>

<h2 id="practice-problems">Practice Problems</h2>

<ol>
  <li>
    <p><strong>Find a Rudrata path</strong>: For the graph with vertices {1,2,3,4} and edges {(1,2), (2,3), (3,4), (1,4)}, find all Rudrata paths. How many are there?</p>
  </li>
  <li>
    <p><strong>Prove the reduction</strong>: Show that Hamiltonian Cycle reduces to Rudrata (s,t)-Path. Can you also show the reverse reduction?</p>
  </li>
  <li>
    <p><strong>DP implementation</strong>: Implement the dynamic programming algorithm for Rudrata Path. Test it on small graphs and analyze its performance.</p>
  </li>
  <li>
    <p><strong>Modify for (s,t)-path</strong>: Modify the DP algorithm to find a Rudrata (s,t)-path. What changes are needed?</p>
  </li>
  <li>
    <p><strong>Time complexity analysis</strong>: For the DP algorithm, verify the O(2ⁿ · n²) time complexity. What is the space complexity?</p>
  </li>
  <li>
    <p><strong>Special cases</strong>: Prove that every tree has a Rudrata path. What about complete graphs?</p>
  </li>
  <li>
    <p><strong>Reduction practice</strong>: Show that Rudrata (s,t)-Path reduces to Rudrata Path. Is the reverse reduction also polynomial-time?</p>
  </li>
  <li>
    <p><strong>Extension</strong>: Research the Traveling Salesman Problem (TSP). How does it relate to Rudrata Path? Can you reduce one to the other?</p>
  </li>
</ol>

<hr />

<p>Understanding the Rudrata Path Problem and its variants provides crucial insight into path and cycle problems in graph theory. The connection to Hamiltonian Cycle and the dynamic programming solution demonstrate important techniques for handling NP-complete graph problems.</p>


        </div>

        <footer class="post-footer">
          <div class="post-navigation"><a href="/blog_algorithms/2025/01/15/np-hard-intro-rudrata-cycle/" class="post-nav-link post-nav-prev">
                <span class="post-nav-label">← Previous</span>
                <span class="post-nav-title">NP-Hard Introduction: Rudrata Cycle</span>
              </a><a href="/blog_algorithms/2025/01/15/np-hard-intro-sat/" class="post-nav-link post-nav-next">
                <span class="post-nav-label">Next →</span>
                <span class="post-nav-title">NP-Hard Introduction: The Boolean Satisfiability Problem (SAT)</span>
              </a></div>
        </footer>
      </article>
    </main>
  </div>

  <!-- Bottom Sections -->
  <div class="post-bottom-sections">
    <div class="bottom-section">
      <h3 class="bottom-section-title">Related Posts</h3>
      <ul class="related-posts-list"><li class="related-post-item">
                  <a href="/blog_algorithms/2025/01/15/np-hard-intro-zero-one-equations/" class="related-post-link">
                    <span class="related-post-title">Linear Programming: Zero-One Equations (ZOE)</span>
                    <span class="related-post-date">Jan 15, 2025</span>
                  </a>
                </li><li class="related-post-item">
                  <a href="/blog_algorithms/2025/01/15/np-hard-intro-vertex-cover/" class="related-post-link">
                    <span class="related-post-title">NP-Hard Introduction: The Vertex Cover Problem</span>
                    <span class="related-post-date">Jan 15, 2025</span>
                  </a>
                </li><li class="related-post-item">
                  <a href="/blog_algorithms/2025/01/15/np-hard-intro-traveling-salesman-problem/" class="related-post-link">
                    <span class="related-post-title">NP-Hard Introduction: Traveling Salesman Problem (TSP)</span>
                    <span class="related-post-date">Jan 15, 2025</span>
                  </a>
                </li><li class="related-post-item">
                  <a href="/blog_algorithms/2025/01/15/np-hard-intro-subset-sum/" class="related-post-link">
                    <span class="related-post-title">NP-Hard Introduction: The Subset Sum Problem</span>
                    <span class="related-post-date">Jan 15, 2025</span>
                  </a>
                </li><li class="related-post-item">
                  <a href="/blog_algorithms/2025/01/15/np-hard-intro-sat/" class="related-post-link">
                    <span class="related-post-title">NP-Hard Introduction: The Boolean Satisfiability Problem (SAT)</span>
                    <span class="related-post-date">Jan 15, 2025</span>
                  </a>
                </li></ul>
    </div>

    <div class="bottom-section">
      <h3 class="bottom-section-title">Recent Posts</h3>
      <ul class="recent-posts-list"><li class="recent-post-item">
              <a href="/blog_algorithms/2025/01/15/np-hard-intro-zero-one-equations/" class="recent-post-link">
                <span class="recent-post-title">Linear Programming: Zero-One Equations (ZOE)</span>
                <span class="recent-post-date">Jan 15, 2025</span>
              </a>
            </li><li class="recent-post-item">
              <a href="/blog_algorithms/2025/01/15/np-hard-intro-vertex-cover/" class="recent-post-link">
                <span class="recent-post-title">NP-Hard Introduction: The Vertex Cover Problem</span>
                <span class="recent-post-date">Jan 15, 2025</span>
              </a>
            </li><li class="recent-post-item">
              <a href="/blog_algorithms/2025/01/15/np-hard-intro-traveling-salesman-problem/" class="recent-post-link">
                <span class="recent-post-title">NP-Hard Introduction: Traveling Salesman Problem (TSP)</span>
                <span class="recent-post-date">Jan 15, 2025</span>
              </a>
            </li><li class="recent-post-item">
              <a href="/blog_algorithms/2025/01/15/np-hard-intro-subset-sum/" class="recent-post-link">
                <span class="recent-post-title">NP-Hard Introduction: The Subset Sum Problem</span>
                <span class="recent-post-date">Jan 15, 2025</span>
              </a>
            </li><li class="recent-post-item">
              <a href="/blog_algorithms/2025/01/15/np-hard-intro-sat/" class="recent-post-link">
                <span class="recent-post-title">NP-Hard Introduction: The Boolean Satisfiability Problem (SAT)</span>
                <span class="recent-post-date">Jan 15, 2025</span>
              </a>
            </li></ul>
    </div>
  </div>
</div>

<script>
(function() {
  // Generate Table of Contents
  function generateTOC() {
    const postContent = document.querySelector('.post-content');
    if (!postContent) return;

    const headings = postContent.querySelectorAll('h2, h3, h4');
    const tocSection = document.querySelector('.toc-section');
    
    if (headings.length === 0) {
      if (tocSection) tocSection.style.display = 'none';
      return;
    }
    
    // Show TOC section if it was hidden
    if (tocSection) tocSection.style.display = 'block';

    const tocList = document.getElementById('tocList');
    if (!tocList) return;

    let tocHTML = '';
    let lastLevel = 0; // Track the level of the last item we processed
    let openLists = 0; // Track how many nested lists are currently open

    headings.forEach((heading, index) => {
      const level = parseInt(heading.tagName.charAt(1));
      // Skip levels beyond 4 (h5, h6) - only process h2, h3, h4
      if (level > 4) return;
      
      const id = heading.id || `heading-${index}`;
      
      // Set ID if not already set
      if (!heading.id) {
        heading.id = id;
      }

      // Close previous list item (except for the first one)
      if (index > 0) {
        tocHTML += '</li>';
      }

      // Close nested lists if we're going up in level (not same level)
      while (openLists > 0 && level < lastLevel) {
        tocHTML += '</ul>';
        openLists--;
      }

      // If going deeper (and we have a previous item), open a new nested list
      // Don't open a list for the first item - it goes in the root list
      if (index > 0 && level > lastLevel) {
        tocHTML += '<ul class="toc-sublist">';
        openLists++;
      }

      // Start new list item
      const text = heading.textContent.trim();
      tocHTML += `<li class="toc-item toc-level-${level}">`;
      tocHTML += `<a href="#${id}" class="toc-link">${text}</a>`;

      lastLevel = level;
    });

    // Close all remaining open items and lists
    if (headings.length > 0) {
      tocHTML += '</li>';
    }
    while (openLists > 0) {
      tocHTML += '</ul>';
      openLists--;
    }

    tocList.innerHTML = tocHTML;

    // Add smooth scroll behavior
    tocList.querySelectorAll('a').forEach(link => {
      link.addEventListener('click', function(e) {
        e.preventDefault();
        const targetId = this.getAttribute('href').substring(1);
        const targetElement = document.getElementById(targetId);
        if (targetElement) {
          const headerOffset = 80;
          const elementPosition = targetElement.getBoundingClientRect().top;
          const offsetPosition = elementPosition + window.pageYOffset - headerOffset;

          window.scrollTo({
            top: offsetPosition,
            behavior: 'smooth'
          });

          // Update active state
          tocList.querySelectorAll('a').forEach(a => a.classList.remove('active'));
          this.classList.add('active');
        }
      });
    });

    // Highlight active section on scroll
    function updateActiveTOC() {
      const scrollPos = window.scrollY + 100;
      let current = '';

      headings.forEach(heading => {
        const headingTop = heading.offsetTop;
        if (scrollPos >= headingTop) {
          current = heading.id;
        }
      });

      tocList.querySelectorAll('a').forEach(link => {
        link.classList.remove('active');
        if (link.getAttribute('href') === '#' + current) {
          link.classList.add('active');
        }
      });
    }

    window.addEventListener('scroll', updateActiveTOC);
    updateActiveTOC();
  }

  // Run when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', generateTOC);
  } else {
    generateTOC();
  }
})();
</script>
</main><footer class="site-footer h-card">
  <data class="u-url" href="/blog_algorithms/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Robina Li</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Robina Li</li><li><a class="u-email" href="mailto:robinali34@gmail.com">robinali34@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><div class="social-links">
  <ul class="social-media-list"><li><a href="https://github.com/robinali34"><svg class="svg-icon"><use xlink:href="/blog_algorithms/assets/minima-social-icons.svg#github"></use></svg> <span class="username">robinali34</span></a></li></ul>
</div>

</div>

      <div class="footer-col footer-col-3">
        <p>Algorithms Blog - Graduate Algorithms course notes and resources</p>
      </div>
    </div>

  </div>

</footer>

</body>
</html>
